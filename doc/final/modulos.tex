\chapter{M\'odulos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Para mantener la simplicidad del dise\~no se utiliza un metodo modular, de tal
manera de independizar las soluciones y focalizar los problemas.\
Es facilmente divisible el dise\~no en dos grandes areas; procesamiento y
potencia.\\

El m\'odulo de procesamiento se encarga principalmente en establecer la
conexi\'on con la computadora, procesar los datos y generar las se\~nales de
control.\
El m\'odulo de potencia es el encargada de manejar los motores, sensores y el
punz\'on.\\

El mantener ambos dise\~nos independientes provee la flexibilidad necesaria
para mantener bajos costos y sencillez de implementaci\'on.


\section{M\'odulo de potencia}\label{cap:motors_section}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Como muestra la figura \ref{fig:pc_uc_motors}, solo se controlan dos motores, y
para mejor precis\'on y mantener el dise\~no compatible con impresoras viejas
matriz de punto, los motores \emph{paso a paso} son la mejor elecci\'on.\\

Existen dos grandes tipos de motores paso a paso; \emph{bipolares} y
\emph{unipolares}. La figura \ref{fig:stepper_motors} muestra la disposici\'on
y conexi\'on de los devanados de ambos tipos de motores. 


%http://www.electojects.com/motors/02440.gif
\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{./img/02440.png}
\caption{Motores paso a paso.}
\label{fig:stepper_motors}
\end{figure}

Claramente la desventaja que presentan los motores \emph{bipolares} frente a
los \emph{unipolares} es que necesitan invertir el sentido de la corriente en
sus bobinados, esto implica mayor complejidad en el circuito controlador.\
Y en contra partida la mayor ventaja de los motores \emph{unipolares} radica
(mas alla de la simpleza del circuito controlador) en que eran los mas
usados\footnote{Y son mas faciles de encontrar en el mercado local} en la
antiguas impresoras matriz de punto, lo cual es un beneficio mas que importante
para este trabajo.\\

Para satisfacer los dos movimientos mec\'anicos necesarios (rotaci\'on del
rodillo de papel y desplazamiento horizontal del cabezal) el dise\~no requiere
controlar dos motores paso a paso unipolares individuales.\
Entre los motores paso a paso \emph{unipolares}, los mas usados son los de
cuatro fases, mas comunmente denominados \emph{motor de cinco cables}. La
figura \ref{fig:stepper_motor_5_wire} muestra simb\'olicamente la distribucion
interna de los devanados de este tipo de motores.

% http://www.piclist.com/images/member/RB-ezy-Q33/5wire.GIF
\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{./img/5wire.png}
\caption{Motor unipolar paso a paso de 4 fases.}
\label{fig:stepper_motor_5_wire}
\end{figure}

Para lograr la rotaci\'on, cada bobina debe ser energizada de forma
independiente y siguiendo una secuancia particular. El circuito de la figura
\ref{fig:cir_single_coil} satisface los requisitos minimos para energizar una
\'unica bobina.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{./img/cir_single_coil.png}
\caption{Circuito de potencia para una bobina de motor paso a paso unipolar.}
\label{fig:cir_single_coil}
\end{figure}

El divisor resistivo \emph{R2 R3} es una resistencia variable, que junto con
la resistencia de emisor de 1 \ohm  permiten controlar la corriente que circula
por la bobina, de esta manera este circuito puede ser ser usado por diversos
motores de diversas impedancias. Debido a que el el circuito de salida se
conecta directamente a la bobina del motor, y esta puede ser de muy baja
impedancia, el transistor de salida debe ser capaz de manejar corrientes altas,
en este caso se hace uso de un \emph{TIP122}.\
La figura \ref{fig:cir_single_coil_plot} muestra las diferentes tensiones que
actuan en el circuito. 

\begin{figure}[htp]
\centering
\includegraphics[width=15cm]{./img/cir_single_coil_plot.png}
\caption{Simulaci\'on del circuito de potencia para una bobina de motor paso a
paso unipolar.}
\label{fig:cir_single_coil_plot}
\end{figure}

Un motor paso a paso unipolar de cuatro fases tiene cuatro bobinas, para
manejar los dos motores es necesario luego replicar ocho veces este circuito.
El esquematico final se encuentra en el anexo en \fullref{cap:driver_schema}.\\

\section{Modulo de procesamiento}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Si bien no se encuentra dentro del alcance de este trabajo proveer una
soluci\'on para la parte mec\'anica de la impresora, es necesario determinar
con que debe interactuar la parte electr\'onica, esto es; cuales ser\'an las
entradas y cuales ser\'an las salidas.\\

Como se determin\'o anteriormente el mecanismo a usar ser\'a de un \'unico
punz\'on desplazante, esto implica que se debe generar movimiento horizontal
para el cabezal y movimiento vertical para el papel, es necesaria adem\'as una
se\~nal para manejar el punz\'on. Quedan entonces definidas las salidas.\
Por otra parte es necesario definir algun tipo de se\~nal de entrada. Para
mantener un dise\~no simple solo se usar\'an entonces una se\~nal de presencia
de papel y un fin de carrera para el cabezal.\\

En la figura \ref{fig:pc_uc_motors} se ve el dise\~no general. \'Este posee la
particularidad de ser el usado por la mayoria de las antiguas impresoras
matriz de punto, siendo entonces posible usar un mecanismo fabricado a medida,
o bien adaptar una impresora vieja.


\begin{figure}[htp]
\centering
\includegraphics[width=13cm]{./img/pc_uc_motors.png}
\caption{Dise\~no de alto nivel.}
\label{fig:pc_uc_motors}
\end{figure}

Para mantener los costos bajos, y teniendo en cuenta las limitaciones del
microcontrolador elegido, la mayor parte del procesamiento se lleva a cabo
en la computadora, logrando de esta manera economizar espacio en el firmware y
evitar la neceidad de hardware extra.\\

En su mayoria, las impresoras braille comerciales posen integrado un sistema
sintetizador de voz, con mensajes pregrabados en varios idiomas que se
reproducen por cada acci\'on que la impresora ejecuta. Esto, claro est\'a,
implica la necesidad de grandes cantidades de memoria y quiz\'a un chip
dedicado. Para evitar usar chips sintetizadores de voz y memeorias, y
teniendo en cuenta que la mayoria de las computadoras actuales poseen sistemas
de reproducc\'on de audio, \'este trabajo queda a cargo de \'estas.\
Al igual que el audio, existe gran cantidad de prcesamiento a llevar a cabo
para la conversi\'on del texto a braille, y varias decisiones que usualmente
toman las impresoras. Todo esto se resuelve del lado de la computadora.\
Entonces es posible ahora, hablar de driver (que ser\'a el programa
ejecutandose en la computadora) y firmware (que ser\'a el programa ejecutandose
en el microcontrolador) al referirnos a la computadora y a el dispositivo
respectivamente.\
Para lograr esto, el firmware solo es capaz de realizar tareas basicas y
sencillas, respondiendo a instrucciones que el driver envia y reportando los
resultados obtenidos. La figura \ref{fig:driver_firmware} muestra una
representaci\'on de lo dicho anteriormente.\\

\begin{figure}[htp]
\centering
\begin{tikzpicture}[node distance = 10cm, auto]
  \node [block] (driver) {Driver};
  \node [block, right of=driver] (firmware) {Firmware};
  \draw [line] (driver) to [bend right] node [midway] {Datos} (firmware);
  \draw [line] (driver) to [bend left] (firmware) node [midway]
{Instrucciones};
  \draw [line] (firmware) -- node [midway] {Resultados} (driver);
\end{tikzpicture}
\caption{Canales de comunicaci\'on entre el driver y el firmware.}
\label{fig:driver_firmware}
\end{figure}


Para instanciar el modelo anterior haciendo uso del m\'etodo de comunicaci\'on
elegido\footnote{Esto es el estandar USB}, se definen dos
endopoints\footnote{V\'ease \fullref{cap:usb_endpoints}} bidireccionales, uno
dedicado exclusivamente al envio de datos (endpoint 1 o EP1) y otro para enviar
instucciones y recibir resultados (endpoint 2 o EP2). La figura
\ref{fig:driver_eps_firmware} muestra la comunicaci\'on mediante endpoints.


\begin{figure}[htp]
\centering
\begin{tikzpicture}[node distance = 10cm, auto]
  \node [block] (driver) {Driver};
  \node [block, right of=driver] (firmware) {Firmware};
  \draw [line] (driver) (1.2,0.6) -- (8.8,0.6) node [midway] {Datos - EP1}
(firmware);
  \draw [line] (driver) (1.2,0) -- (8.8,0) node [midway] {Instrucciones - EP2
Out} (firmware);
  \draw [latex-] (firmware) (1.2,-0.6) -- (8.8,-0.6) node [midway]
{Resultados - EP2 In} (driver);
\end{tikzpicture}
\caption{Canales de comunicaci\'on entre el driver y el firmware mediante
endpoints.}
\label{fig:driver_eps_firmware}
\end{figure}

Habiendo definido los canales de comunicaci\'on y sus respectiva funciones, es
necesario determina el tipo y forma de los datos y las instrucciones a manejar.

\subsubsection{Datos}
%%%%%%%%%%%%%%%%%%
%
La cantidad de caracteres braille que entran en el ancho de una hoja A4, ronda
los 30 dependiendo del tama\~no de las sangrias. Para dejar un margen se eligen
28 caracteres. Teniendo en cuenta que los caracteres braille poseen dos
columnas de puntos\footnote{V\'ease \fullref{cap:braille_cell}} y que el
dato m\'inimo que se puede enviar por USB es de un byte\footnote{V\'ease
\fullref{cap:usb_byte}}, para completar una linea a lo ancho de una p\'agina de
una fila de puntos se necesitan:

\begin{center}
$28 caracteres * 2 puntos = 56 bits$\\
$56 bits / 8  = 7 bytes$
\end{center}

\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|} \hline
\braille{c} \braille{c} \braille{c} \braille{c} &
\braille{c} \braille{c} \braille{c} \braille{c} &
... 												 \\ \hline
byte 1 & byte 2 & ...\\ \hline
\end{tabular}
\caption{Bytes por puntos braille} 
\label{tab:bytes_braille}
\end{table}

Entonces el m\'aximo numero de bytes a enviar por linea es de 7 bytes.\
Para formar una fila completa de caracteres, es necesario realizar tres
envios, ya que los caracteres braille poseen tres filas de
puntos\footnote{V\'ease \fullref{cap:braille_cell}}, lo cual genera 21 bytes
($7bytes*3$) por fila, y un total de 588 ($21bytes * 28filas$) bytes por
p\'agina ya que en una hoja A4 se suelen imprimir 28 filas de caracteres. 

\subsubsection{Instrucciones}
%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Para limitar la capacidad de funcionalidades del dispositivo solo se
definen ocho instrucciones b\'asicas descriptas en la tabla
\ref{tab:instructions_set}.

\begin{table}[ht]
\centering
\begin{tabular}{|l|c|l|} 												\hline
\rowcolor[gray]{.9}
Instrucci\'on & Byte & Descripci\'on 								\\ 	\hline
RESET 		&	0x01	&	Resetea el cabezal	al punto de origen	\\	\hline
PRINT 		&	0x02	&	Imprime los datos						\\	\hline
MOV\_SHORT 	&  	0x03	&	Desplaza el cabezal entre puntos		\\	\hline
MOV\_LONG  	&  	0x04	&	Desplaza el cabezal entre caracteres	\\	\hline
ROT\_SHORT 	&	0x05	&	Rota el rodillo entre lineas			\\	\hline
ROT\_LONG   &	0x06	&	Rota el rodillo entre caracteres		\\	\hline
PULL\_PAPER	&	0x07	&	Rota el rodillo hasta sacar el papel	\\	\hline
STATUS		&	0x08	&	Pide el estado de los sensores			\\	\hline
\end{tabular}
\caption{Instrucciones de impresi\'on} 
\label{tab:instructions_set}
\end{table}

Este set de instrucciones proporcionan todas las funcionalidades necesarias
para poder llevar a acabo un proceso de impresi\'on normal.

\subsubsection{Resultados}
%%%%%%%%%%%%%%%%%%%%%%%
%
Se definen dos tipos de resultados distintos, uno que es devuelto cuando se
envia la instruccion \emph{STATUS} y otro que se genera siempre luego de un
envio de datos que consta en el dato recreado por la impresora, esto es solo a
modo de verificaci\'on tipo \emph{echo}.\\

Ante una instrucci\'on del tipo \emph{STATUS}, el dispositivo lee los estados
de los dos sensores y genera un byte de reporte descripto en la tabla
\ref{tab:report_byte}.


\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}									\hline
\multicolumn{8}{|c|}{Byte}										\\	\hline
x & x & x & x & x & x & 1/0 & 1/0 								\\ 	\hline
- & - & - & - & - & - & Sensor de cabezal & Sensor de papel		\\	\hline
\end{tabular}
\caption{Byte de reporte} 
\label{tab:report_byte}
\end{table}

Entonces dependiendo del estado de los dos bits menos significativos del byte
de reporte, el driver puede saber en que estado se encuentra la impresora.\\

El segundo tipo de resultado definido es el \emph{echo}. Cuando el driver
envia datos para imprimir, la impresora comienza el proceso de impresi\'on y
recrea los datos recibidos segun lo que hace, luego este dato recreado
se envia de vuelta al driver quien comprar ambos datos y verifica que sean
iguales, la figura \ref{fig:rec_dat} muestra un diagrama simplificado de este
proceso.

\begin{figure}[htp]
\centering
\begin{scriptsize}
\begin{tikzpicture}
  [auto,
   decision/.style={diamond, draw=blue, thick, fill=blue!20,
                    text width=9em, text badly centered,
                    inner sep=1pt},
   block/.style   ={rectangle, draw=blue, thick, fill=blue!20,
                    text width=10em, text centered, rounded corners,
                    minimum height=4em},
   line/.style    ={draw, thick, -latex' ,shorten >=2pt},
   cloud/.style   ={draw=red, thick, ellipse,fill=red!20,
                    minimum height=2em}]
  \matrix [column sep=10mm,row sep=7mm]
  {
    % row 1
      \node [cloud] (driver)   		{Driver}; & 
		&
      \node [cloud] (firmware) 		{Firmware}; \\
    % row 2
	  \node [block] (dat_send_d)	{Envio del dato a imprimir \(\$dat_d\)}; &
		&
      \node [block] (dat_resv_f)	{Recepci\'on del dato \(\$dat_d\)}; \\
    % row 3
     	& &
      \node [block] (print) 		{Proceso de impresi\'on y
reconstrucci\'on del dato \(\$dat_d -> \$dat_f\)};  \\
    % row 4
	\node	[block]	(dat_resv_d)	{Recepci\'on del dato reconstruido
	\(\$dat_f\)};
		& &
	  \node [block] (dat_send_f)	{Envio del dato reconstruido \(\$dat_f\)};
\\
  };
  \begin{scope}[every path/.style={draw, -latex'}]
    \path	(dat_send_d) -- (dat_resv_f) node [midway] {EP1 Out};
    \path	(dat_resv_f) -- (print);
    \path   (print)      -- (dat_send_f);
    \path   (dat_send_f) -- (dat_resv_d) node [midway] {EP2 In};;
  \end{scope}
\end{tikzpicture}
\end{scriptsize}
\caption{Proceso de recontrucci\'on de datos}
\label{fig:rec_dat}
\end{figure}

\subsection{Manejo de motores}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Como se explica en \fullref{cap:motors_section}, se requieren dos motores, lo
cual implica tener a disposici\'on ocho se\~nales de control. Para ello se hace
uso del puerto B del microcontrolador, el cual posee la particularidad de estar
provisto de resistencias de \emph{pull-up} programables. De esta manera los
dos motores pueden controlarse mediante la escritura de un \'unico puerto.\
La figura \ref{fig:uc_portb_motors} muestra la conexi\'on del puerto B del
microcontrolador a la ficha de se\~nales de los motores.


\begin{figure}[htp]
\centering
\includegraphics[width=7cm]{./img/uc_portb_motors.png}
\caption{Puerto B del uC conectado a las se\~nales de control de los motores
paso a paso.}
\label{fig:uc_portb_motors}
\end{figure}


Teniendo en cuenta la figura \ref{fig:stepper_motor_5_wire}, y tomando el
valor '1' como ``energizado'', las secuencias de la tabla
\ref{tab:seq_motors_1}, indistintamente, efectuan la rotaci\'on de el motor en
un paso completo.

\begin{table}[htp]
\centering
\begin{tabular}{l c|c|c|c|c|}
Bobina A+ & & 1 & 0 & 0 & 0 \\	
Bobina B+ & & 0 & 0 & 1 & 0 \\
Bobina A- &	& 0 & 1 & 0 & 0 \\
Bobina B- &	& 0 & 0 & 0 & 1 \\
							\\
Bobina A+ & & 1 & 1 & 0 & 0 \\
Bobina B+ &	& 0 & 0 & 1 & 1 \\
Bobina A- &	& 0 & 1 & 1 & 0 \\ 
Bobina B- &	& 1 & 0 & 0 & 1 \\
							\\
Tiempo	...					\\
\end{tabular}
\caption{Secuencias de un paso para motores paso a paso unipolares de cuatro
fases.}
\label{tab:seq_motors_1}
\end{table}

Es posible combinar ambas secuencias para obtener incrementos de medio paso
como se ve en la tabla \ref{tab:seq_motors_2}, de esta manera se obtiene una
mejor precisi\'on en la rotaci\'on del motor.

\begin{table}[htp]
\centering
\begin{tabular}{l c|c|c|c|c|c|c|c|c|}
Bobina A+ & & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1\\	
Bobina B+ & & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0\\
Bobina A- &	& 0 & 1 & 1 & 1 & 0 & 0 & 0 & 0\\
Bobina B- &	& 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1\\
							\\
Tiempo	...					\\
\end{tabular}
\caption{Secuencia de medio paso para motores paso a paso unipolares de cuatro
fases.}
\label{tab:seq_motors_2}
\end{table}



\clearpage
\begin{lstlisting}
/**
 * move() -     Function to move both motors
 * @loops:      Number of loops of a complete sequence
 * @direction:  Direction to move (RIGHT/LEFT, UP/DOWN)
 * @motor:      Which motor to move (CAR/ROLLER) 
 *
 * This function moves each motor in a defined direction and a specific
 * amount of turns depending on the parameters that are passed to it.
 **/
void move(byte loops, byte direction, byte motor) 
{
        byte stepsI[8] = {0x77, 0x33, 0xbb, 0x99, 0xdd, 0xcc, 0xee, 0x66};
        byte stepsD[8] = {0x66, 0xee, 0xcc, 0xdd, 0x99, 0xbb, 0x33, 0x77}; 
        byte val, i, loops_aux;

        if (direction)
                for (loops_aux = 0; loops_aux < loops; loops_aux++) {
                        for (i = 0; i < 8; i++) {		
                                val = stepsI[i];
                                if (motor) {
                                        PORTB = (PORTB & 0xf0) | (val & 0x0f);
                                        delay(50);
                                } else {
                                        PORTB = (PORTB & 0x0f) | (val & 0xf0);
                                        delay(50);
                                }
                        }
                }
        else
                for (loops_aux = 0; loops_aux < loops; loops_aux++) {
                        for (i = 0; i < 8; i++) {		
                                val = stepsD[i];
                                if (motor) {
                                        PORTB = (PORTB & 0xf0) | (val & 0x0f);
                                        delay(50);
                                } else {
                                        PORTB = (PORTB & 0x0f) | (val & 0xf0);
                                        delay(50);
                                }
                        }
                }
}
\end{lstlisting}
