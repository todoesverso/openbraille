gplink-0.13.4 alpha
Copyright (c) 1998-2005 gputils project
Listing File Generated: 4-30-2008  21:26:15
 
 
Address  Value    Disassembly              Source
-------  -----    -----------              ------
                                           ;--------------------------------------------------------
                                           ; File Created by SDCC : free open source ANSI-C Compiler
                                           ; Version 2.7.0 #4818 (Jan 18 2008)
                                           ; This file generated Wed Apr 30 21:26:15 2008
                                           ;--------------------------------------------------------
                                           ; PIC16 port for the Microchip 16-bit core micros
                                           ;--------------------------------------------------------
                                           	list	p=18f4550
                                           	__config 0x300000, 0x20
                                           	__config 0x300001, 0x3
                                           	__config 0x300002, 0x20
                                           	__config 0x300003, 0x0
                                           	__config 0x300005, 0x1
                                           	__config 0x300006, 0x80
                                           	__config 0x300008, 0xff
                                           	__config 0x300009, 0xff
                                           	__config 0x30000a, 0xff
                                           	__config 0x30000b, 0xff
                                           	__config 0x30000c, 0xff
                                           	__config 0x30000d, 0xff
                                           
                                           	radix dec
                                           
                                           ;--------------------------------------------------------
                                           ; public variables in this module
                                           ;--------------------------------------------------------
                                           	global _txBuffer
                                           	global _rxBuffer
                                           	global _pagina
                                           	global _UserInit
                                           	global _delay
                                           	global _golpear
                                           	global _check_driver
                                           	global _desplazar
                                           	global _rotar
                                           	global _volvercarro
                                           	global _check_bit
                                           	global _print_byte
                                           	global _print_line
                                           	global _print_page
                                           	global _apagar_motores
                                           	global _mover
                                           	global _reset_carro
                                           	global _ProcessIO
                                           	global _main
                                           
                                           ;--------------------------------------------------------
                                           ; extern variables in this module
                                           ;--------------------------------------------------------
                                           	extern _SPPDATAbits
                                           	extern _SPPCFGbits
                                           	extern _SPPEPSbits
                                           	extern _SPPCONbits
                                           	extern _UFRMLbits
                                           	extern _UFRMHbits
                                           	extern _UIRbits
                                           	extern _UIEbits
                                           	extern _UEIRbits
                                           	extern _UEIEbits
                                           	extern _USTATbits
                                           	extern _UCONbits
                                           	extern _UADDRbits
                                           	extern _UCFGbits
                                           	extern _UEP0bits
                                           	extern _UEP1bits
                                           	extern _UEP2bits
                                           	extern _UEP3bits
                                           	extern _UEP4bits
                                           	extern _UEP5bits
                                           	extern _UEP6bits
                                           	extern _UEP7bits
                                           	extern _UEP8bits
                                           	extern _UEP9bits
                                           	extern _UEP10bits
                                           	extern _UEP11bits
                                           	extern _UEP12bits
                                           	extern _UEP13bits
                                           	extern _UEP14bits
                                           	extern _UEP15bits
                                           	extern _PORTAbits
                                           	extern _PORTBbits
                                           	extern _PORTCbits
                                           	extern _PORTDbits
                                           	extern _PORTEbits
                                           	extern _LATAbits
                                           	extern _LATBbits
                                           	extern _LATCbits
                                           	extern _LATDbits
                                           	extern _LATEbits
                                           	extern _TRISAbits
                                           	extern _TRISBbits
                                           	extern _TRISCbits
                                           	extern _TRISDbits
                                           	extern _TRISEbits
                                           	extern _OSCTUNEbits
                                           	extern _PIE1bits
                                           	extern _PIR1bits
                                           	extern _IPR1bits
                                           	extern _PIE2bits
                                           	extern _PIR2bits
                                           	extern _IPR2bits
                                           	extern _EECON1bits
                                           	extern _RCSTAbits
                                           	extern _TXSTAbits
                                           	extern _T3CONbits
                                           	extern _CMCONbits
                                           	extern _CVRCONbits
                                           	extern _ECCP1ASbits
                                           	extern _ECCP1DELbits
                                           	extern _BAUDCONbits
                                           	extern _CCP2CONbits
                                           	extern _CCP1CONbits
                                           	extern _ADCON2bits
                                           	extern _ADCON1bits
                                           	extern _ADCON0bits
                                           	extern _SSPCON2bits
                                           	extern _SSPCON1bits
                                           	extern _SSPSTATbits
                                           	extern _T2CONbits
                                           	extern _T1CONbits
                                           	extern _RCONbits
                                           	extern _WDTCONbits
                                           	extern _HLVDCONbits
                                           	extern _OSCCONbits
                                           	extern _T0CONbits
                                           	extern _STATUSbits
                                           	extern _FSR2Hbits
                                           	extern _BSRbits
                                           	extern _FSR1Hbits
                                           	extern _FSR0Hbits
                                           	extern _INTCON3bits
                                           	extern _INTCON2bits
                                           	extern _INTCONbits
                                           	extern _TBLPTRUbits
                                           	extern _PCLATHbits
                                           	extern _PCLATUbits
                                           	extern _STKPTRbits
                                           	extern _TOSUbits
                                           	extern _stdin
                                           	extern _stdout
                                           	extern _deviceState
                                           	extern _selfPowered
                                           	extern _remoteWakeup
                                           	extern _currentConfiguration
                                           	extern _ep0Bo
                                           	extern _ep0Bi
                                           	extern _ep1Bo
                                           	extern _ep1Bi
                                           	extern _SetupPacket
                                           	extern _RxBuff
                                           	extern _outPtr
                                           	extern _inPtr
                                           	extern _wCount
                                           	extern _SPPDATA
                                           	extern _SPPCFG
                                           	extern _SPPEPS
                                           	extern _SPPCON
                                           	extern _UFRML
                                           	extern _UFRMH
                                           	extern _UIR
                                           	extern _UIE
                                           	extern _UEIR
                                           	extern _UEIE
                                           	extern _USTAT
                                           	extern _UCON
                                           	extern _UADDR
                                           	extern _UCFG
                                           	extern _UEP0
                                           	extern _UEP1
                                           	extern _UEP2
                                           	extern _UEP3
                                           	extern _UEP4
                                           	extern _UEP5
                                           	extern _UEP6
                                           	extern _UEP7
                                           	extern _UEP8
                                           	extern _UEP9
                                           	extern _UEP10
                                           	extern _UEP11
                                           	extern _UEP12
                                           	extern _UEP13
                                           	extern _UEP14
                                           	extern _UEP15
                                           	extern _PORTA
                                           	extern _PORTB
                                           	extern _PORTC
                                           	extern _PORTD
                                           	extern _PORTE
                                           	extern _LATA
                                           	extern _LATB
                                           	extern _LATC
                                           	extern _LATD
                                           	extern _LATE
                                           	extern _TRISA
                                           	extern _TRISB
                                           	extern _TRISC
                                           	extern _TRISD
                                           	extern _TRISE
                                           	extern _OSCTUNE
                                           	extern _PIE1
                                           	extern _PIR1
                                           	extern _IPR1
                                           	extern _PIE2
                                           	extern _PIR2
                                           	extern _IPR2
                                           	extern _EECON1
                                           	extern _EECON2
                                           	extern _EEDATA
                                           	extern _EEADR
                                           	extern _RCSTA
                                           	extern _TXSTA
                                           	extern _TXREG
                                           	extern _RCREG
                                           	extern _SPBRG
                                           	extern _SPBRGH
                                           	extern _T3CON
                                           	extern _TMR3L
                                           	extern _TMR3H
                                           	extern _CMCON
                                           	extern _CVRCON
                                           	extern _ECCP1AS
                                           	extern _ECCP1DEL
                                           	extern _BAUDCON
                                           	extern _CCP2CON
                                           	extern _CCPR2L
                                           	extern _CCPR2H
                                           	extern _CCP1CON
                                           	extern _CCPR1L
                                           	extern _CCPR1H
                                           	extern _ADCON2
                                           	extern _ADCON1
                                           	extern _ADCON0
                                           	extern _ADRESL
                                           	extern _ADRESH
                                           	extern _SSPCON2
                                           	extern _SSPCON1
                                           	extern _SSPSTAT
                                           	extern _SSPADD
                                           	extern _SSPBUF
                                           	extern _T2CON
                                           	extern _PR2
                                           	extern _TMR2
                                           	extern _T1CON
                                           	extern _TMR1L
                                           	extern _TMR1H
                                           	extern _RCON
                                           	extern _WDTCON
                                           	extern _HLVDCON
                                           	extern _OSCCON
                                           	extern _T0CON
                                           	extern _TMR0L
                                           	extern _TMR0H
                                           	extern _STATUS
                                           	extern _FSR2L
                                           	extern _FSR2H
                                           	extern _PLUSW2
                                           	extern _PREINC2
                                           	extern _POSTDEC2
                                           	extern _POSTINC2
                                           	extern _INDF2
                                           	extern _BSR
                                           	extern _FSR1L
                                           	extern _FSR1H
                                           	extern _PLUSW1
                                           	extern _PREINC1
                                           	extern _POSTDEC1
                                           	extern _POSTINC1
                                           	extern _INDF1
                                           	extern _WREG
                                           	extern _FSR0L
                                           	extern _FSR0H
                                           	extern _PLUSW0
                                           	extern _PREINC0
                                           	extern _POSTDEC0
                                           	extern _POSTINC0
                                           	extern _INDF0
                                           	extern _INTCON3
                                           	extern _INTCON2
                                           	extern _INTCON
                                           	extern _PRODL
                                           	extern _PRODH
                                           	extern _TABLAT
                                           	extern _TBLPTRL
                                           	extern _TBLPTRH
                                           	extern _TBLPTRU
                                           	extern _PCL
                                           	extern _PCLATH
                                           	extern _PCLATU
                                           	extern _STKPTR
                                           	extern _TOSL
                                           	extern _TOSH
                                           	extern _TOSU
                                           	extern _ProcessUSBTransactions
                                           	extern _BulkOut
                                           	extern _BulkIn
                                           	extern __mulint
                                           ;--------------------------------------------------------
                                           ;	Equates to used internal registers
                                           ;--------------------------------------------------------
                                           STATUS	equ	0xfd8
                                           WREG	equ	0xfe8
                                           FSR0L	equ	0xfe9
                                           FSR0H	equ	0xfea
                                           FSR1L	equ	0xfe1
                                           FSR2L	equ	0xfd9
                                           INDF0	equ	0xfef
                                           POSTDEC1	equ	0xfe5
                                           PREINC1	equ	0xfe4
                                           PLUSW2	equ	0xfdb
                                           PRODL	equ	0xff3
                                           
                                           
                                           ; Internal registers
                                           .registers	udata_ovr	0x0000
                                           r0x00	res	1
                                           r0x01	res	1
                                           r0x02	res	1
                                           r0x03	res	1
                                           r0x04	res	1
                                           r0x05	res	1
                                           r0x06	res	1
                                           r0x07	res	1
                                           r0x08	res	1
                                           r0x09	res	1
                                           r0x0a	res	1
                                           r0x0b	res	1
                                           r0x0c	res	1
                                           r0x0d	res	1
                                           r0x0e	res	1
                                           
                                           udata_main_0	udata
                                           _pagina	res	64
                                           
                                           udata_main_1	udata
                                           _mover_pasos_1_1	res	8
                                           
                                           udata_main_2	udata
                                           _rxBuffer	res	64
                                           
                                           udata_main_3	udata
                                           _txBuffer	res	64
                                           
                                           ;--------------------------------------------------------
                                           ; interrupt vector 
                                           ;--------------------------------------------------------
                                           
                                           ;--------------------------------------------------------
                                           ; global & static initialisations
                                           ;--------------------------------------------------------
                                           ; I code from now on!
                                           ; ; Starting pCode block
                                           S_main__main	code
                                           _main:
                                           ;	.line	408; main.c	ADCON1 |= 0x0F;
00097c   0e0f     movlw	0xf                	MOVLW	0x0f
00097e   12c1     iorwf	0xc1, 0x1, 0       	IORWF	_ADCON1, F
                                           ;	.line	411; main.c	UCFG = 0x14; // Habilita las resistencias de pullup; modo full speed
000980   0e14     movlw	0x14               	MOVLW	0x14
000982   6e6f     movwf	0x6f, 0            	MOVWF	_UCFG
000984   0100     movlb	0                  	BANKSEL	_deviceState
                                           ;	.line	414; main.c	deviceState = DETACHED;
000986   6bfb     clrf	0xfb, 0x1           	CLRF	_deviceState, B
000988   0100     movlb	0                  	BANKSEL	_remoteWakeup
                                           ;	.line	415; main.c	remoteWakeup = 0x00;
00098a   6bfa     clrf	0xfa, 0x1           	CLRF	_remoteWakeup, B
00098c   0100     movlb	0                  	BANKSEL	_currentConfiguration
                                           ;	.line	416; main.c	currentConfiguration = 0x00;
00098e   6bfc     clrf	0xfc, 0x1           	CLRF	_currentConfiguration, B
                                           ;	.line	420; main.c	UserInit();
000990   ecda     call	0x15b4, 0           	CALL	_UserInit
000992   f00a
                                           ;	.line	422; main.c	golpear();
000994   ecb5     call	0x156a, 0           	CALL	_golpear
000996   f00a
                                           ;	.line	424; main.c	a = mover(0, 134, IZQ, CARRO);
000998   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00099a   0e01     movlw	0x1                	MOVLW	0x01
00099c   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
00099e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009a0   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009a2   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009a4   0e86     movlw	0x86               	MOVLW	0x86
0009a6   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009a8   0e00     movlw	0                  	MOVLW	0x00
0009aa   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009ac   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009ae   ec15     call	0x2a, 0             	CALL	_mover
0009b0   f000
0009b2   0e08     movlw	0x8                	MOVLW	0x08
0009b4   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	425; main.c	golpear();
0009b6   ecb5     call	0x156a, 0           	CALL	_golpear
0009b8   f00a
                                           ;	.line	426; main.c	golpear();
0009ba   ecb5     call	0x156a, 0           	CALL	_golpear
0009bc   f00a
                                           ;	.line	427; main.c	b = mover (0, 134, ABAJ, RODILLO);
0009be   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009c0   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009c2   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009c4   0e01     movlw	0x1                	MOVLW	0x01
0009c6   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009c8   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009ca   0e86     movlw	0x86               	MOVLW	0x86
0009cc   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009ce   0e00     movlw	0                  	MOVLW	0x00
0009d0   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009d2   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009d4   ec15     call	0x2a, 0             	CALL	_mover
0009d6   f000
0009d8   0e08     movlw	0x8                	MOVLW	0x08
0009da   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	428; main.c	golpear();
0009dc   ecb5     call	0x156a, 0           	CALL	_golpear
0009de   f00a
                                           ;	.line	429; main.c	golpear();
0009e0   ecb5     call	0x156a, 0           	CALL	_golpear
0009e2   f00a
                                           ;	.line	430; main.c	golpear();
0009e4   ecb5     call	0x156a, 0           	CALL	_golpear
0009e6   f00a
                                           ;	.line	431; main.c	a = mover(0, 134, DER, CARRO);
0009e8   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009ea   0e01     movlw	0x1                	MOVLW	0x01
0009ec   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009ee   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009f0   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009f2   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009f4   0e86     movlw	0x86               	MOVLW	0x86
0009f6   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0009f8   0e00     movlw	0                  	MOVLW	0x00
0009fa   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009fc   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0009fe   ec15     call	0x2a, 0             	CALL	_mover
000a00   f000
000a02   0e08     movlw	0x8                	MOVLW	0x08
000a04   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	433; main.c	golpear();
000a06   ecb5     call	0x156a, 0           	CALL	_golpear
000a08   f00a
                                           ;	.line	434; main.c	a = mover(0, 134, DER, CARRO);
000a0a   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a0c   0e01     movlw	0x1                	MOVLW	0x01
000a0e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000a10   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a12   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000a14   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a16   0e86     movlw	0x86               	MOVLW	0x86
000a18   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000a1a   0e00     movlw	0                  	MOVLW	0x00
000a1c   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a1e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a20   ec15     call	0x2a, 0             	CALL	_mover
000a22   f000
000a24   0e08     movlw	0x8                	MOVLW	0x08
000a26   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	435; main.c	golpear();
000a28   ecb5     call	0x156a, 0           	CALL	_golpear
000a2a   f00a
                                           ;	.line	436; main.c	golpear();
000a2c   ecb5     call	0x156a, 0           	CALL	_golpear
000a2e   f00a
                                           ;	.line	437; main.c	b = mover (0, 134, ARR, RODILLO);
000a30   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a32   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a34   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a36   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a38   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a3a   0e86     movlw	0x86               	MOVLW	0x86
000a3c   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000a3e   0e00     movlw	0                  	MOVLW	0x00
000a40   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a42   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000a44   ec15     call	0x2a, 0             	CALL	_mover
000a46   f000
000a48   0e08     movlw	0x8                	MOVLW	0x08
000a4a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	438; main.c	golpear();
000a4c   ecb5     call	0x156a, 0           	CALL	_golpear
000a4e   f00a
                                           ;	.line	439; main.c	golpear();
000a50   ecb5     call	0x156a, 0           	CALL	_golpear
000a52   f00a
                                           ;	.line	440; main.c	golpear();
000a54   ecb5     call	0x156a, 0           	CALL	_golpear
000a56   f00a
                                           ;	.line	441; main.c	apagar_motores();
000a58   ec27     call	0x164e, 0           	CALL	_apagar_motores
000a5a   f00b
                                           ;	.line	455; main.c	apagar_motores();
000a5c   ec27     call	0x164e, 0           	CALL	_apagar_motores
000a5e   f00b
                                           _00342_DS_:
                                           ;	.line	460; main.c	while(1)
000a60   d7ff     bra	0xa60                	BRA	_00342_DS_
000a62   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__ProcessIO	code
                                           _ProcessIO:
                                           ;	.line	400; main.c	}
001656   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__USBEcho	code
                                           _USBEcho:
                                           ;	.line	351; main.c	static void USBEcho(void)
000d10   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000d12   ffe5
000d14   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000d16   ffe5
000d18   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000d1a   ffe5
000d1c   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000d1e   ffe5
000d20   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
000d22   ffe5
                                           ;	.line	356; main.c	rxCnt = BulkOut(rxBuffer, OUTPUT_BYTES);
000d24   0e00     movlw	0                  	MOVLW	HIGH(_rxBuffer)
000d26   6e01     movwf	0x1, 0             	MOVWF	r0x01
000d28   0ea0     movlw	0xa0               	MOVLW	LOW(_rxBuffer)
000d2a   6e00     movwf	0, 0               	MOVWF	r0x00
000d2c   0e80     movlw	0x80               	MOVLW	0x80
000d2e   6e02     movwf	0x2, 0             	MOVWF	r0x02
000d30   0e40     movlw	0x40               	MOVLW	0x40
000d32   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000d34   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000d36   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000d38   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000d3a   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000d3c   5000     movf	0, 0, 0             	MOVF	r0x00, W
000d3e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000d40   ec47     call	0x88e, 0            	CALL	_BulkOut
000d42   f004
000d44   6e00     movwf	0, 0               	MOVWF	r0x00
000d46   0e04     movlw	0x4                	MOVLW	0x04
000d48   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ; #	MOVF	r0x00, W
                                           ; #	BTFSS	STATUS, 2
                                           ; #	GOTO	_00332_DS_
                                           ; #	GOTO	_00328_DS_
                                           ; #	CLRF	r0x00
                                           ;	.line	358; main.c	if (rxCnt == 0) return;
000d4a   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ;	.line	360; main.c	for(i=0;i<OUTPUT_BYTES;i++)
000d4c   b4d8     btfsc	0xd8, 0x2, 0       	BTFSC	STATUS, 2
000d4e   d03d     bra	0xdca                	BRA	_00328_DS_
000d50   6a00     clrf	0, 0                	CLRF	r0x00
                                           _00324_DS_:
000d52   0e40     movlw	0x40               	MOVLW	0x40
000d54   5c00     subwf	0, 0, 0            	SUBWF	r0x00, W
000d56   e21a     bc	0xd8c                 	BC	_00327_DS_
                                           ;	.line	361; main.c	pagina[i]=rxBuffer[i];
000d58   0e60     movlw	0x60               	MOVLW	LOW(_pagina)
000d5a   2400     addwf	0, 0, 0            	ADDWF	r0x00, W
000d5c   6e01     movwf	0x1, 0             	MOVWF	r0x01
000d5e   6a02     clrf	0x2, 0              	CLRF	r0x02
000d60   0e00     movlw	0                  	MOVLW	HIGH(_pagina)
000d62   2202     addwfc	0x2, 0x1, 0       	ADDWFC	r0x02, F
000d64   0ea0     movlw	0xa0               	MOVLW	LOW(_rxBuffer)
000d66   2400     addwf	0, 0, 0            	ADDWF	r0x00, W
000d68   6e03     movwf	0x3, 0             	MOVWF	r0x03
000d6a   6a04     clrf	0x4, 0              	CLRF	r0x04
000d6c   0e00     movlw	0                  	MOVLW	HIGH(_rxBuffer)
000d6e   2204     addwfc	0x4, 0x1, 0       	ADDWFC	r0x04, F
000d70   c003     movff	0x3, 0xfe9         	MOVFF	r0x03, FSR0L
000d72   ffe9
000d74   c004     movff	0x4, 0xfea         	MOVFF	r0x04, FSR0H
000d76   ffea
000d78   cfef     movff	0xfef, 0x3         	MOVFF	INDF0, r0x03
000d7a   f003
000d7c   c001     movff	0x1, 0xfe9         	MOVFF	r0x01, FSR0L
000d7e   ffe9
000d80   c002     movff	0x2, 0xfea         	MOVFF	r0x02, FSR0H
000d82   ffea
000d84   c003     movff	0x3, 0xfef         	MOVFF	r0x03, INDF0
000d86   ffef
                                           ;	.line	360; main.c	for(i=0;i<OUTPUT_BYTES;i++)
000d88   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
000d8a   d7e3     bra	0xd52                	BRA	_00324_DS_
                                           _00327_DS_:
                                           ;	.line	365; main.c	print_page();
000d8c   ecd6     call	0x11ac, 0           	CALL	_print_page
000d8e   f008
                                           ;	.line	366; main.c	txBuffer[0]= 0x12;
000d90   0e12     movlw	0x12               	MOVLW	0x12
000d92   0101     movlb	0x1                	BANKSEL	_txBuffer
000d94   6f00     movwf	0, 0x1             	MOVWF	_txBuffer, B
                                           ;	.line	367; main.c	txBuffer[1]= 0xab;
000d96   0eab     movlw	0xab               	MOVLW	0xab
                                           ; removed redundant BANKSEL
000d98   6f01     movwf	0x1, 0x1           	MOVWF	(_txBuffer + 1), B
                                           _00321_DS_:
000d9a   0104     movlb	0x4                	BANKSEL	_ep1Bi
                                           ;	.line	369; main.c	while (ep1Bi.Stat & UOWN)
000d9c   af0c     btfss	0xc, 0x7, 0x1      	BTFSS	_ep1Bi, 7, B
000d9e   d003     bra	0xda6                	BRA	_00323_DS_
                                           ;	.line	370; main.c	ProcessUSBTransactions(); 
000da0   ec56     call	0x12ac, 0           	CALL	_ProcessUSBTransactions
000da2   f009
000da4   d7fa     bra	0xd9a                	BRA	_00321_DS_
                                           _00323_DS_:
                                           ;	.line	372; main.c	BulkIn(txBuffer, 2);
000da6   0e01     movlw	0x1                	MOVLW	HIGH(_txBuffer)
000da8   6e01     movwf	0x1, 0             	MOVWF	r0x01
000daa   0e00     movlw	0                  	MOVLW	LOW(_txBuffer)
000dac   6e00     movwf	0, 0               	MOVWF	r0x00
000dae   0e80     movlw	0x80               	MOVLW	0x80
000db0   6e02     movwf	0x2, 0             	MOVWF	r0x02
000db2   0e02     movlw	0x2                	MOVLW	0x02
000db4   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000db6   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000db8   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000dba   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000dbc   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000dbe   5000     movf	0, 0, 0             	MOVF	r0x00, W
000dc0   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000dc2   ec19     call	0xc32, 0            	CALL	_BulkIn
000dc4   f006
000dc6   0e04     movlw	0x4                	MOVLW	0x04
000dc8   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           _00328_DS_:
000dca   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000dcc   f004
000dce   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000dd0   f003
000dd2   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000dd4   f002
000dd6   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000dd8   f001
000dda   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000ddc   f000
000dde   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__imprimir	code
                                           _imprimir:
                                           ;	.line	313; main.c	static void imprimir(void)
00025e   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000260   ffe5
000262   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000264   ffe5
000266   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000268   ffe5
00026a   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
00026c   ffe5
00026e   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
000270   ffe5
000272   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
000274   ffe5
000276   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
000278   ffe5
00027a   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
00027c   ffe5
00027e   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
000280   ffe5
000282   c009     movff	0x9, 0xfe5         	MOVFF	r0x09, POSTDEC1
000284   ffe5
                                           ;	.line	318; main.c	i=0;
000286   6a00     clrf	0, 0                	CLRF	r0x00
                                           _00283_DS_:
                                           ;	.line	319; main.c	while (i < 3)
000288   0e03     movlw	0x3                	MOVLW	0x03
00028a   5c00     subwf	0, 0, 0            	SUBWF	r0x00, W
00028c   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00028e   d067     bra	0x35e                	BRA	_00297_DS_
                                           ;	.line	321; main.c	for(l = 0; l < 3; l++)
000290   6a01     clrf	0x1, 0              	CLRF	r0x01
000292   6a02     clrf	0x2, 0              	CLRF	r0x02
                                           _00293_DS_:
000294   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000296   0f80     addlw	0x80               	ADDLW	0x80
000298   0f80     addlw	0x80               	ADDLW	0x80
00029a   e102     bnz	0x2a0                	BNZ	_00313_DS_
00029c   0e03     movlw	0x3                	MOVLW	0x03
00029e   5c01     subwf	0x1, 0, 0          	SUBWF	r0x01, W
                                           _00313_DS_:
0002a0   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
0002a2   d053     bra	0x34a                	BRA	_00296_DS_
                                           ;	.line	323; main.c	for (j = 0; j < 7; j++)  // Para imprimir una linea
0002a4   c000     movff	0, 0x3             	MOVFF	r0x00, r0x03
0002a6   f003
0002a8   6a04     clrf	0x4, 0              	CLRF	r0x04
0002aa   6a05     clrf	0x5, 0              	CLRF	r0x05
                                           _00289_DS_:
0002ac   5005     movf	0x5, 0, 0           	MOVF	r0x05, W
0002ae   0f80     addlw	0x80               	ADDLW	0x80
0002b0   0f80     addlw	0x80               	ADDLW	0x80
0002b2   e102     bnz	0x2b8                	BNZ	_00314_DS_
0002b4   0e07     movlw	0x7                	MOVLW	0x07
0002b6   5c04     subwf	0x4, 0, 0          	SUBWF	r0x04, W
                                           _00314_DS_:
0002b8   e239     bc	0x32c                 	BC	_00310_DS_
                                           ;	.line	326; main.c	mascara = 0x80; // Para la lectura del primer bit
0002ba   0e80     movlw	0x80               	MOVLW	0x80
0002bc   6e06     movwf	0x6, 0             	MOVWF	r0x06
                                           ;	.line	327; main.c	aux = pagina[i] & mascara;
0002be   0e60     movlw	0x60               	MOVLW	LOW(_pagina)
0002c0   2403     addwf	0x3, 0, 0          	ADDWF	r0x03, W
0002c2   6e07     movwf	0x7, 0             	MOVWF	r0x07
0002c4   6a08     clrf	0x8, 0              	CLRF	r0x08
0002c6   0e00     movlw	0                  	MOVLW	HIGH(_pagina)
0002c8   2208     addwfc	0x8, 0x1, 0       	ADDWFC	r0x08, F
0002ca   c007     movff	0x7, 0xfe9         	MOVFF	r0x07, FSR0L
0002cc   ffe9
0002ce   c008     movff	0x8, 0xfea         	MOVFF	r0x08, FSR0H
0002d0   ffea
0002d2   cfef     movff	0xfef, 0x7         	MOVFF	INDF0, r0x07
0002d4   f007
0002d6   0e80     movlw	0x80               	MOVLW	0x80
0002d8   1607     andwf	0x7, 0x1, 0        	ANDWF	r0x07, F
                                           ;	.line	329; main.c	for (k = 0; k < 4; k++)
0002da   0e04     movlw	0x4                	MOVLW	0x04
0002dc   6e08     movwf	0x8, 0             	MOVWF	r0x08
0002de   6a09     clrf	0x9, 0              	CLRF	r0x09
                                           _00288_DS_:
                                           ;	.line	331; main.c	if (aux)
0002e0   5007     movf	0x7, 0, 0           	MOVF	r0x07, W
0002e2   e002     bz	0x2e8                 	BZ	_00280_DS_
                                           ;	.line	332; main.c	golpear();
0002e4   ecb5     call	0x156a, 0           	CALL	_golpear
0002e6   f00a
                                           _00280_DS_:
                                           ;	.line	333; main.c	desplazar(1); // Desplazamiento corto
0002e8   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0002ea   0e01     movlw	0x1                	MOVLW	0x01
0002ec   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0002ee   ec3d     call	0x147a, 0           	CALL	_desplazar
0002f0   f00a
0002f2   0e02     movlw	0x2                	MOVLW	0x02
0002f4   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	334; main.c	mascara = mascara >> 1; // Para lectura del siguiente bit
0002f6   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
0002f8   3206     rrcf	0x6, 0x1, 0         	RRCF	r0x06, F
                                           ; #	MOVF	r0x07, W
                                           ; #	BTFSC	STATUS, 2
                                           ; #	GOTO	_00282_DS_
                                           ; #	CALL	_golpear
                                           ; #	MOVLW	0x00
                                           ;	.line	336; main.c	if (aux)
0002fa   5007     movf	0x7, 0, 0           	MOVF	r0x07, W
                                           ;	.line	337; main.c	golpear();
0002fc   a4d8     btfss	0xd8, 0x2, 0       	BTFSS	STATUS, 2
                                           ;	.line	338; main.c	desplazar(2); // Deplazamiento largo
0002fe   ecb5     call	0x156a, 0           	CALL	_golpear
000300   f00a
000302   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000304   0e02     movlw	0x2                	MOVLW	0x02
000306   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000308   ec3d     call	0x147a, 0           	CALL	_desplazar
00030a   f00a
00030c   0e02     movlw	0x2                	MOVLW	0x02
00030e   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	339; main.c	mascara = mascara >> 1;
000310   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
000312   3206     rrcf	0x6, 0x1, 0         	RRCF	r0x06, F
000314   0eff     movlw	0xff               	MOVLW	0xff
000316   2608     addwf	0x8, 0x1, 0        	ADDWF	r0x08, F
000318   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
00031a   0609     decf	0x9, 0x1, 0         	DECF	r0x09, F
                                           ;	.line	329; main.c	for (k = 0; k < 4; k++)
00031c   5008     movf	0x8, 0, 0           	MOVF	r0x08, W
00031e   1009     iorwf	0x9, 0, 0          	IORWF	r0x09, W
000320   e1df     bnz	0x2e0                	BNZ	_00288_DS_
                                           ;	.line	341; main.c	i++;
000322   2a03     incf	0x3, 0x1, 0         	INCF	r0x03, F
                                           ;	.line	323; main.c	for (j = 0; j < 7; j++)  // Para imprimir una linea
000324   2a04     incf	0x4, 0x1, 0         	INCF	r0x04, F
000326   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000328   2a05     incf	0x5, 0x1, 0         	INCF	r0x05, F
00032a   d7c0     bra	0x2ac                	BRA	_00289_DS_
                                           _00310_DS_:
00032c   c003     movff	0x3, 0             	MOVFF	r0x03, r0x00
00032e   f000
                                           ;	.line	343; main.c	rotar(1);
000330   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000332   0e01     movlw	0x1                	MOVLW	0x01
000334   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000336   ec17     call	0x142e, 0           	CALL	_rotar
000338   f00a
00033a   0e02     movlw	0x2                	MOVLW	0x02
00033c   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	344; main.c	volvercarro();
00033e   ec05     call	0x160a, 0           	CALL	_volvercarro
000340   f00b
                                           ;	.line	321; main.c	for(l = 0; l < 3; l++)
000342   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
000344   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000346   2a02     incf	0x2, 0x1, 0         	INCF	r0x02, F
000348   d7a5     bra	0x294                	BRA	_00293_DS_
                                           _00296_DS_:
                                           ;	.line	346; main.c	rotar(2);
00034a   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00034c   0e02     movlw	0x2                	MOVLW	0x02
00034e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000350   ec17     call	0x142e, 0           	CALL	_rotar
000352   f00a
000354   0e02     movlw	0x2                	MOVLW	0x02
000356   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	347; main.c	volvercarro();
000358   ec05     call	0x160a, 0           	CALL	_volvercarro
00035a   f00b
00035c   d795     bra	0x288                	BRA	_00283_DS_
                                           _00297_DS_:
00035e   cfe4     movff	0xfe4, 0x9         	MOVFF	PREINC1, r0x09
000360   f009
000362   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
000364   f008
000366   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
000368   f007
00036a   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
00036c   f006
00036e   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
000370   f005
000372   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000374   f004
000376   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000378   f003
00037a   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
00037c   f002
00037e   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000380   f001
000382   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000384   f000
000386   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__reset_carro	code
                                           _reset_carro:
                                           ;	.line	295; main.c	int reset_carro(void)
00137c   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
00137e   ffe5
001380   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
001382   ffe5
                                           ;	.line	300; main.c	while(SENSOR_CARRO) {
001384   6a00     clrf	0, 0                	CLRF	r0x00
001386   6a01     clrf	0x1, 0              	CLRF	r0x01
                                           _00272_DS_:
001388   a483     btfss	0x83, 0x2, 0       	BTFSS	_PORTDbits, 2
00138a   d020     bra	0x13cc               	BRA	_00274_DS_
                                           ;	.line	302; main.c	mover(0, 1, DER, CARRO);
00138c   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00138e   0e01     movlw	0x1                	MOVLW	0x01
001390   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001392   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001394   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001396   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001398   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
00139a   0e00     movlw	0                  	MOVLW	0x00
00139c   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00139e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013a0   ec15     call	0x2a, 0             	CALL	_mover
0013a2   f000
0013a4   0e08     movlw	0x8                	MOVLW	0x08
0013a6   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	303; main.c	mover(0, 1, DER, RODILLO);
0013a8   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013aa   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013ac   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013ae   0e01     movlw	0x1                	MOVLW	0x01
0013b0   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0013b2   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013b4   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0013b6   0e00     movlw	0                  	MOVLW	0x00
0013b8   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013ba   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0013bc   ec15     call	0x2a, 0             	CALL	_mover
0013be   f000
0013c0   0e08     movlw	0x8                	MOVLW	0x08
0013c2   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	304; main.c	contador++;
0013c4   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
0013c6   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
0013c8   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
0013ca   d7de     bra	0x1388               	BRA	_00272_DS_
                                           _00274_DS_:
                                           ;	.line	307; main.c	apagar_motores();
0013cc   ec27     call	0x164e, 0           	CALL	_apagar_motores
0013ce   f00b
                                           ;	.line	309; main.c	return contador;
0013d0   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
0013d2   fff3
0013d4   5000     movf	0, 0, 0             	MOVF	r0x00, W
0013d6   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
0013d8   f001
0013da   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0013dc   f000
0013de   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__mover	code
                                           _mover:
                                           ;	.line	244; main.c	int mover(int paso, int loops, int direccion, int motor)
00002a   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
00002c   ffe5
00002e   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
000030   ffd9
000032   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000034   ffe5
000036   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000038   ffe5
00003a   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
00003c   ffe5
00003e   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000040   ffe5
000042   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
000044   ffe5
000046   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
000048   ffe5
00004a   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
00004c   ffe5
00004e   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
000050   ffe5
000052   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
000054   ffe5
000056   c009     movff	0x9, 0xfe5         	MOVFF	r0x09, POSTDEC1
000058   ffe5
00005a   c00a     movff	0xa, 0xfe5         	MOVFF	r0x0a, POSTDEC1
00005c   ffe5
00005e   c00b     movff	0xb, 0xfe5         	MOVFF	r0x0b, POSTDEC1
000060   ffe5
000062   c00c     movff	0xc, 0xfe5         	MOVFF	r0x0c, POSTDEC1
000064   ffe5
000066   c00d     movff	0xd, 0xfe5         	MOVFF	r0x0d, POSTDEC1
000068   ffe5
00006a   c00e     movff	0xe, 0xfe5         	MOVFF	r0x0e, POSTDEC1
00006c   ffe5
00006e   0e02     movlw	0x2                	MOVLW	0x02
000070   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
000072   f000
000074   0e03     movlw	0x3                	MOVLW	0x03
000076   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
000078   f001
00007a   0e04     movlw	0x4                	MOVLW	0x04
00007c   cfdb     movff	0xfdb, 0x2         	MOVFF	PLUSW2, r0x02
00007e   f002
000080   0e05     movlw	0x5                	MOVLW	0x05
000082   cfdb     movff	0xfdb, 0x3         	MOVFF	PLUSW2, r0x03
000084   f003
000086   0e06     movlw	0x6                	MOVLW	0x06
000088   cfdb     movff	0xfdb, 0x4         	MOVFF	PLUSW2, r0x04
00008a   f004
00008c   0e07     movlw	0x7                	MOVLW	0x07
00008e   cfdb     movff	0xfdb, 0x5         	MOVFF	PLUSW2, r0x05
000090   f005
000092   0e08     movlw	0x8                	MOVLW	0x08
000094   cfdb     movff	0xfdb, 0x6         	MOVFF	PLUSW2, r0x06
000096   f006
000098   0e09     movlw	0x9                	MOVLW	0x09
00009a   cfdb     movff	0xfdb, 0x7         	MOVFF	PLUSW2, r0x07
00009c   f007
                                           ;	.line	246; main.c	byte pasos[8]={0x77, 0x33, 0xbb, 0x99, 0xdd, 0xcc, 0xee, 0x66}, valor;
00009e   0e77     movlw	0x77               	MOVLW	0x77
0000a0   0100     movlb	0                  	BANKSEL	_mover_pasos_1_1
0000a2   6fe0     movwf	0xe0, 0x1          	MOVWF	_mover_pasos_1_1, B
0000a4   0e33     movlw	0x33               	MOVLW	0x33
                                           ; removed redundant BANKSEL
0000a6   6fe1     movwf	0xe1, 0x1          	MOVWF	(_mover_pasos_1_1 + 1), B
0000a8   0ebb     movlw	0xbb               	MOVLW	0xbb
                                           ; removed redundant BANKSEL
0000aa   6fe2     movwf	0xe2, 0x1          	MOVWF	(_mover_pasos_1_1 + 2), B
0000ac   0e99     movlw	0x99               	MOVLW	0x99
                                           ; removed redundant BANKSEL
0000ae   6fe3     movwf	0xe3, 0x1          	MOVWF	(_mover_pasos_1_1 + 3), B
0000b0   0edd     movlw	0xdd               	MOVLW	0xdd
                                           ; removed redundant BANKSEL
0000b2   6fe4     movwf	0xe4, 0x1          	MOVWF	(_mover_pasos_1_1 + 4), B
0000b4   0ecc     movlw	0xcc               	MOVLW	0xcc
                                           ; removed redundant BANKSEL
0000b6   6fe5     movwf	0xe5, 0x1          	MOVWF	(_mover_pasos_1_1 + 5), B
0000b8   0eee     movlw	0xee               	MOVLW	0xee
                                           ; removed redundant BANKSEL
0000ba   6fe6     movwf	0xe6, 0x1          	MOVWF	(_mover_pasos_1_1 + 6), B
0000bc   0e66     movlw	0x66               	MOVLW	0x66
                                           ; removed redundant BANKSEL
0000be   6fe7     movwf	0xe7, 0x1          	MOVWF	(_mover_pasos_1_1 + 7), B
                                           ;	.line	249; main.c	paso_aux = paso;
0000c0   c000     movff	0, 0x8             	MOVFF	r0x00, r0x08
0000c2   f008
0000c4   c001     movff	0x1, 0x9           	MOVFF	r0x01, r0x09
0000c6   f009
                                           ;	.line	251; main.c	if(direccion)
0000c8   5004     movf	0x4, 0, 0           	MOVF	r0x04, W
0000ca   1005     iorwf	0x5, 0, 0          	IORWF	r0x05, W
0000cc   b4d8     btfsc	0xd8, 0x2, 0       	BTFSC	STATUS, 2
0000ce   d04e     bra	0x16c                	BRA	_00255_DS_
                                           ;	.line	253; main.c	for(loops_aux=0; loops_aux < loops; loops_aux++)
0000d0   6a04     clrf	0x4, 0              	CLRF	r0x04
0000d2   6a05     clrf	0x5, 0              	CLRF	r0x05
                                           _00231_DS_:
0000d4   5005     movf	0x5, 0, 0           	MOVF	r0x05, W
0000d6   0f80     addlw	0x80               	ADDLW	0x80
0000d8   6ef3     movwf	0xf3, 0            	MOVWF	PRODL
0000da   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
0000dc   0f80     addlw	0x80               	ADDLW	0x80
0000de   5cf3     subwf	0xf3, 0, 0         	SUBWF	PRODL, W
0000e0   e102     bnz	0xe6                 	BNZ	_00260_DS_
0000e2   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
0000e4   5c04     subwf	0x4, 0, 0          	SUBWF	r0x04, W
                                           _00260_DS_:
0000e6   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
0000e8   d096     bra	0x216                	BRA	_00226_DS_
                                           ;	.line	255; main.c	for(i = paso_aux; i < 8; i++)
0000ea   c008     movff	0x8, 0xa           	MOVFF	r0x08, r0x0a
0000ec   f00a
0000ee   c009     movff	0x9, 0xb           	MOVFF	r0x09, r0x0b
0000f0   f00b
                                           _00227_DS_:
0000f2   500b     movf	0xb, 0, 0           	MOVF	r0x0b, W
0000f4   0f80     addlw	0x80               	ADDLW	0x80
0000f6   0f80     addlw	0x80               	ADDLW	0x80
0000f8   e102     bnz	0xfe                 	BNZ	_00261_DS_
0000fa   0e08     movlw	0x8                	MOVLW	0x08
0000fc   5c0a     subwf	0xa, 0, 0          	SUBWF	r0x0a, W
                                           _00261_DS_:
0000fe   e230     bc	0x160                 	BC	_00230_DS_
                                           ;	.line	257; main.c	valor = pasos[i];
000100   0ee0     movlw	0xe0               	MOVLW	LOW(_mover_pasos_1_1)
000102   240a     addwf	0xa, 0, 0          	ADDWF	r0x0a, W
000104   6e0c     movwf	0xc, 0             	MOVWF	r0x0c
000106   0e00     movlw	0                  	MOVLW	HIGH(_mover_pasos_1_1)
000108   200b     addwfc	0xb, 0, 0         	ADDWFC	r0x0b, W
00010a   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
00010c   c00c     movff	0xc, 0xfe9         	MOVFF	r0x0c, FSR0L
00010e   ffe9
000110   c00d     movff	0xd, 0xfea         	MOVFF	r0x0d, FSR0H
000112   ffea
000114   cfef     movff	0xfef, 0xc         	MOVFF	INDF0, r0x0c
000116   f00c
                                           ;	.line	258; main.c	if(motor)	
000118   5006     movf	0x6, 0, 0           	MOVF	r0x06, W
00011a   1007     iorwf	0x7, 0, 0          	IORWF	r0x07, W
00011c   e00f     bz	0x13c                 	BZ	_00219_DS_
                                           ;	.line	260; main.c	PORTB = (PORTB & 0xf0) | (valor & 0x0f);
00011e   0ef0     movlw	0xf0               	MOVLW	0xf0
000120   1481     andwf	0x81, 0, 0         	ANDWF	_PORTB, W
000122   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
000124   0e0f     movlw	0xf                	MOVLW	0x0f
000126   140c     andwf	0xc, 0, 0          	ANDWF	r0x0c, W
                                           ; #	MOVWF	r0x0e
                                           ; #	MOVF	r0x0e, W
000128   100d     iorwf	0xd, 0, 0          	IORWF	r0x0d, W
00012a   6e81     movwf	0x81, 0            	MOVWF	_PORTB
                                           ;	.line	261; main.c	delay(50);
00012c   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00012e   0e32     movlw	0x32               	MOVLW	0x32
000130   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000132   ec8b     call	0x1316, 0           	CALL	_delay
000134   f009
000136   0e02     movlw	0x2                	MOVLW	0x02
000138   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
00013a   d00e     bra	0x158                	BRA	_00229_DS_
                                           _00219_DS_:
                                           ;	.line	265; main.c	PORTB = (PORTB & 0x0f) | (valor & 0xf0);
00013c   0e0f     movlw	0xf                	MOVLW	0x0f
00013e   1481     andwf	0x81, 0, 0         	ANDWF	_PORTB, W
000140   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
000142   0ef0     movlw	0xf0               	MOVLW	0xf0
000144   140c     andwf	0xc, 0, 0          	ANDWF	r0x0c, W
                                           ; #	MOVWF	r0x0e
                                           ; #	MOVF	r0x0e, W
000146   100d     iorwf	0xd, 0, 0          	IORWF	r0x0d, W
000148   6e81     movwf	0x81, 0            	MOVWF	_PORTB
                                           ;	.line	266; main.c	delay(50);
00014a   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
00014c   0e32     movlw	0x32               	MOVLW	0x32
00014e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000150   ec8b     call	0x1316, 0           	CALL	_delay
000152   f009
000154   0e02     movlw	0x2                	MOVLW	0x02
000156   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           _00229_DS_:
                                           ;	.line	255; main.c	for(i = paso_aux; i < 8; i++)
000158   2a0a     incf	0xa, 0x1, 0         	INCF	r0x0a, F
00015a   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00015c   2a0b     incf	0xb, 0x1, 0         	INCF	r0x0b, F
00015e   d7c9     bra	0xf2                 	BRA	_00227_DS_
                                           _00230_DS_:
                                           ;	.line	269; main.c	paso_aux=0;
000160   6a08     clrf	0x8, 0              	CLRF	r0x08
000162   6a09     clrf	0x9, 0              	CLRF	r0x09
                                           ;	.line	253; main.c	for(loops_aux=0; loops_aux < loops; loops_aux++)
000164   2a04     incf	0x4, 0x1, 0         	INCF	r0x04, F
000166   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000168   2a05     incf	0x5, 0x1, 0         	INCF	r0x05, F
00016a   d7b4     bra	0xd4                 	BRA	_00231_DS_
                                           _00255_DS_:
                                           ;	.line	273; main.c	for(loops_aux=0; loops_aux < loops; loops_aux++){
00016c   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
00016e   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000170   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
000172   6a04     clrf	0x4, 0              	CLRF	r0x04
000174   6a05     clrf	0x5, 0              	CLRF	r0x05
                                           _00239_DS_:
000176   5005     movf	0x5, 0, 0           	MOVF	r0x05, W
000178   0f80     addlw	0x80               	ADDLW	0x80
00017a   6ef3     movwf	0xf3, 0            	MOVWF	PRODL
00017c   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
00017e   0f80     addlw	0x80               	ADDLW	0x80
000180   5cf3     subwf	0xf3, 0, 0         	SUBWF	PRODL, W
000182   e102     bnz	0x188                	BNZ	_00266_DS_
000184   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000186   5c04     subwf	0x4, 0, 0          	SUBWF	r0x04, W
                                           _00266_DS_:
000188   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00018a   d045     bra	0x216                	BRA	_00226_DS_
                                           ;	.line	274; main.c	for(i = paso+1; i > 0; i--)
00018c   c000     movff	0, 0xa             	MOVFF	r0x00, r0x0a
00018e   f00a
000190   c001     movff	0x1, 0xb           	MOVFF	r0x01, r0x0b
000192   f00b
                                           _00235_DS_:
000194   500b     movf	0xb, 0, 0           	MOVF	r0x0b, W
000196   0f80     addlw	0x80               	ADDLW	0x80
000198   0f80     addlw	0x80               	ADDLW	0x80
00019a   e102     bnz	0x1a0                	BNZ	_00267_DS_
00019c   0e01     movlw	0x1                	MOVLW	0x01
00019e   5c0a     subwf	0xa, 0, 0          	SUBWF	r0x0a, W
                                           _00267_DS_:
0001a0   e333     bnc	0x208                	BNC	_00238_DS_
                                           ;	.line	276; main.c	valor = pasos[i];
0001a2   0ee0     movlw	0xe0               	MOVLW	LOW(_mover_pasos_1_1)
0001a4   240a     addwf	0xa, 0, 0          	ADDWF	r0x0a, W
0001a6   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
0001a8   0e00     movlw	0                  	MOVLW	HIGH(_mover_pasos_1_1)
0001aa   200b     addwfc	0xb, 0, 0         	ADDWFC	r0x0b, W
0001ac   6e0e     movwf	0xe, 0             	MOVWF	r0x0e
0001ae   c00d     movff	0xd, 0xfe9         	MOVFF	r0x0d, FSR0L
0001b0   ffe9
0001b2   c00e     movff	0xe, 0xfea         	MOVFF	r0x0e, FSR0H
0001b4   ffea
0001b6   cfef     movff	0xfef, 0xc         	MOVFF	INDF0, r0x0c
0001b8   f00c
                                           ;	.line	277; main.c	if(motor)		
0001ba   5006     movf	0x6, 0, 0           	MOVF	r0x06, W
0001bc   1007     iorwf	0x7, 0, 0          	IORWF	r0x07, W
0001be   e00f     bz	0x1de                 	BZ	_00222_DS_
                                           ;	.line	279; main.c	PORTB = (PORTB & 0xf0) | (valor & 0x0f);
0001c0   0ef0     movlw	0xf0               	MOVLW	0xf0
0001c2   1481     andwf	0x81, 0, 0         	ANDWF	_PORTB, W
0001c4   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
0001c6   0e0f     movlw	0xf                	MOVLW	0x0f
0001c8   140c     andwf	0xc, 0, 0          	ANDWF	r0x0c, W
                                           ; #	MOVWF	r0x0e
                                           ; #	MOVF	r0x0e, W
0001ca   100d     iorwf	0xd, 0, 0          	IORWF	r0x0d, W
0001cc   6e81     movwf	0x81, 0            	MOVWF	_PORTB
                                           ;	.line	280; main.c	delay(50);
0001ce   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0001d0   0e32     movlw	0x32               	MOVLW	0x32
0001d2   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0001d4   ec8b     call	0x1316, 0           	CALL	_delay
0001d6   f009
0001d8   0e02     movlw	0x2                	MOVLW	0x02
0001da   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
0001dc   d010     bra	0x1fe                	BRA	_00237_DS_
                                           _00222_DS_:
                                           ;	.line	284; main.c	PORTB = (PORTB & 0x0f) | (valor & 0xf0);
0001de   0e0f     movlw	0xf                	MOVLW	0x0f
0001e0   1481     andwf	0x81, 0, 0         	ANDWF	_PORTB, W
0001e2   6e0d     movwf	0xd, 0             	MOVWF	r0x0d
0001e4   0ef0     movlw	0xf0               	MOVLW	0xf0
0001e6   140c     andwf	0xc, 0, 0          	ANDWF	r0x0c, W
                                           ; #	MOVWF	r0x0e
                                           ; #	MOVF	r0x0e, W
0001e8   100d     iorwf	0xd, 0, 0          	IORWF	r0x0d, W
0001ea   6e81     movwf	0x81, 0            	MOVWF	_PORTB
                                           ;	.line	285; main.c	PORTB |= valor;;
0001ec   500c     movf	0xc, 0, 0           	MOVF	r0x0c, W
0001ee   1281     iorwf	0x81, 0x1, 0       	IORWF	_PORTB, F
                                           ;	.line	286; main.c	delay(50);
0001f0   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0001f2   0e32     movlw	0x32               	MOVLW	0x32
0001f4   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0001f6   ec8b     call	0x1316, 0           	CALL	_delay
0001f8   f009
0001fa   0e02     movlw	0x2                	MOVLW	0x02
0001fc   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           _00237_DS_:
                                           ;	.line	274; main.c	for(i = paso+1; i > 0; i--)
0001fe   0eff     movlw	0xff               	MOVLW	0xff
000200   260a     addwf	0xa, 0x1, 0        	ADDWF	r0x0a, F
000202   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
000204   060b     decf	0xb, 0x1, 0         	DECF	r0x0b, F
000206   d7c6     bra	0x194                	BRA	_00235_DS_
                                           _00238_DS_:
                                           ;	.line	289; main.c	paso_aux = 7;
000208   0e07     movlw	0x7                	MOVLW	0x07
00020a   6e08     movwf	0x8, 0             	MOVWF	r0x08
00020c   6a09     clrf	0x9, 0              	CLRF	r0x09
                                           ;	.line	273; main.c	for(loops_aux=0; loops_aux < loops; loops_aux++){
00020e   2a04     incf	0x4, 0x1, 0         	INCF	r0x04, F
000210   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000212   2a05     incf	0x5, 0x1, 0         	INCF	r0x05, F
000214   d7b0     bra	0x176                	BRA	_00239_DS_
                                           _00226_DS_:
                                           ;	.line	292; main.c	return paso_aux;
000216   c009     movff	0x9, 0xff3         	MOVFF	r0x09, PRODL
000218   fff3
00021a   5008     movf	0x8, 0, 0           	MOVF	r0x08, W
00021c   cfe4     movff	0xfe4, 0xe         	MOVFF	PREINC1, r0x0e
00021e   f00e
000220   cfe4     movff	0xfe4, 0xd         	MOVFF	PREINC1, r0x0d
000222   f00d
000224   cfe4     movff	0xfe4, 0xc         	MOVFF	PREINC1, r0x0c
000226   f00c
000228   cfe4     movff	0xfe4, 0xb         	MOVFF	PREINC1, r0x0b
00022a   f00b
00022c   cfe4     movff	0xfe4, 0xa         	MOVFF	PREINC1, r0x0a
00022e   f00a
000230   cfe4     movff	0xfe4, 0x9         	MOVFF	PREINC1, r0x09
000232   f009
000234   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
000236   f008
000238   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
00023a   f007
00023c   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
00023e   f006
000240   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
000242   f005
000244   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000246   f004
000248   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
00024a   f003
00024c   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
00024e   f002
000250   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000252   f001
000254   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000256   f000
000258   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
00025a   ffd9
00025c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__apagar_motores	code
                                           _apagar_motores:
                                           ;	.line	239; main.c	PORTB = 0x00;
00164e   6a81     clrf	0x81, 0             	CLRF	_PORTB
001650   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__print_page	code
                                           _print_page:
                                           ;	.line	219; main.c	void print_page(void)
0011ac   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0011ae   ffe5
0011b0   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0011b2   ffe5
                                           ;	.line	222; main.c	for(i = 0; i < NUMLINES; i++)
0011b4   6a00     clrf	0, 0                	CLRF	r0x00
0011b6   6a01     clrf	0x1, 0              	CLRF	r0x01
                                           _00201_DS_:
0011b8   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
0011ba   0f80     addlw	0x80               	ADDLW	0x80
0011bc   0f80     addlw	0x80               	ADDLW	0x80
0011be   e102     bnz	0x11c4               	BNZ	_00209_DS_
0011c0   0e03     movlw	0x3                	MOVLW	0x03
0011c2   5c00     subwf	0, 0, 0            	SUBWF	r0x00, W
                                           _00209_DS_:
0011c4   e236     bc	0x1232                	BC	_00205_DS_
                                           ;	.line	224; main.c	print_line(i);
0011c6   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
0011c8   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0011ca   5000     movf	0, 0, 0             	MOVF	r0x00, W
0011cc   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0011ce   ec8d     call	0x111a, 0           	CALL	_print_line
0011d0   f008
0011d2   0e02     movlw	0x2                	MOVLW	0x02
0011d4   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	225; main.c	rotar(1);
0011d6   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0011d8   0e01     movlw	0x1                	MOVLW	0x01
0011da   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0011dc   ec17     call	0x142e, 0           	CALL	_rotar
0011de   f00a
0011e0   0e02     movlw	0x2                	MOVLW	0x02
0011e2   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	226; main.c	i++;
0011e4   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
0011e6   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
0011e8   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
                                           ;	.line	227; main.c	print_line(i);
0011ea   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
0011ec   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0011ee   5000     movf	0, 0, 0             	MOVF	r0x00, W
0011f0   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0011f2   ec8d     call	0x111a, 0           	CALL	_print_line
0011f4   f008
0011f6   0e02     movlw	0x2                	MOVLW	0x02
0011f8   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	228; main.c	rotar(1);
0011fa   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0011fc   0e01     movlw	0x1                	MOVLW	0x01
0011fe   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001200   ec17     call	0x142e, 0           	CALL	_rotar
001202   f00a
001204   0e02     movlw	0x2                	MOVLW	0x02
001206   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	229; main.c	i++;
001208   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
00120a   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00120c   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
                                           ;	.line	230; main.c	print_line(i);
00120e   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
001210   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001212   5000     movf	0, 0, 0             	MOVF	r0x00, W
001214   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001216   ec8d     call	0x111a, 0           	CALL	_print_line
001218   f008
00121a   0e02     movlw	0x2                	MOVLW	0x02
00121c   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	231; main.c	rotar(2);
00121e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001220   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001222   ec17     call	0x142e, 0           	CALL	_rotar
001224   f00a
001226   0e02     movlw	0x2                	MOVLW	0x02
001228   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	222; main.c	for(i = 0; i < NUMLINES; i++)
00122a   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
00122c   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00122e   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
001230   d7c3     bra	0x11b8               	BRA	_00201_DS_
                                           _00205_DS_:
001232   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
001234   f001
001236   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001238   f000
00123a   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__print_line	code
                                           _print_line:
                                           ;	.line	210; main.c	void print_line(int linea)
00111a   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
00111c   ffe5
00111e   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
001120   ffd9
001122   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
001124   ffe5
001126   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
001128   ffe5
00112a   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
00112c   ffe5
00112e   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
001130   ffe5
001132   0e02     movlw	0x2                	MOVLW	0x02
001134   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
001136   f000
001138   0e03     movlw	0x3                	MOVLW	0x03
00113a   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
00113c   f001
                                           ;	.line	213; main.c	j = linea*BYTESXLINEA;
00113e   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
001140   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001142   5000     movf	0, 0, 0             	MOVF	r0x00, W
001144   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001146   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001148   0e03     movlw	0x3                	MOVLW	0x03
00114a   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
00114c   eca3     call	0xf46, 0            	CALL	__mulint
00114e   f007
001150   6e00     movwf	0, 0               	MOVWF	r0x00
001152   cff3     movff	0xff3, 0x1         	MOVFF	PRODL, r0x01
001154   f001
001156   0e04     movlw	0x4                	MOVLW	0x04
001158   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	214; main.c	for (i = j; i < j + BYTESXLINEA; i++)
00115a   0e03     movlw	0x3                	MOVLW	0x03
00115c   2400     addwf	0, 0, 0            	ADDWF	r0x00, W
00115e   6e02     movwf	0x2, 0             	MOVWF	r0x02
001160   0e00     movlw	0                  	MOVLW	0x00
001162   2001     addwfc	0x1, 0, 0         	ADDWFC	r0x01, W
001164   6e03     movwf	0x3, 0             	MOVWF	r0x03
                                           _00187_DS_:
001166   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
001168   0f80     addlw	0x80               	ADDLW	0x80
00116a   6ef3     movwf	0xf3, 0            	MOVWF	PRODL
00116c   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
00116e   0f80     addlw	0x80               	ADDLW	0x80
001170   5cf3     subwf	0xf3, 0, 0         	SUBWF	PRODL, W
001172   e102     bnz	0x1178               	BNZ	_00196_DS_
001174   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
001176   5c00     subwf	0, 0, 0            	SUBWF	r0x00, W
                                           _00196_DS_:
001178   e20c     bc	0x1192                	BC	_00190_DS_
                                           ;	.line	215; main.c	print_byte(i);
00117a   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
00117c   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
00117e   5000     movf	0, 0, 0             	MOVF	r0x00, W
001180   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001182   ecf0     call	0xde0, 0            	CALL	_print_byte
001184   f006
001186   0e02     movlw	0x2                	MOVLW	0x02
001188   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	214; main.c	for (i = j; i < j + BYTESXLINEA; i++)
00118a   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
00118c   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
00118e   2a01     incf	0x1, 0x1, 0         	INCF	r0x01, F
001190   d7ea     bra	0x1166               	BRA	_00187_DS_
                                           _00190_DS_:
                                           ;	.line	216; main.c	volvercarro();
001192   ec05     call	0x160a, 0           	CALL	_volvercarro
001194   f00b
001196   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
001198   f003
00119a   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
00119c   f002
00119e   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
0011a0   f001
0011a2   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0011a4   f000
0011a6   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
0011a8   ffd9
0011aa   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__print_byte	code
                                           _print_byte:
                                           ;	.line	191; main.c	void print_byte(int ind)
000de0   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
000de2   ffe5
000de4   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
000de6   ffd9
000de8   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000dea   ffe5
000dec   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000dee   ffe5
000df0   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000df2   ffe5
000df4   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000df6   ffe5
000df8   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
000dfa   ffe5
000dfc   0e02     movlw	0x2                	MOVLW	0x02
000dfe   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
000e00   f000
000e02   0e03     movlw	0x3                	MOVLW	0x03
000e04   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
000e06   f001
                                           ;	.line	195; main.c	for (i = 8; i > 0; i--)
000e08   0e08     movlw	0x8                	MOVLW	0x08
000e0a   6e02     movwf	0x2, 0             	MOVWF	r0x02
000e0c   6a03     clrf	0x3, 0              	CLRF	r0x03
                                           _00172_DS_:
000e0e   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
000e10   0f80     addlw	0x80               	ADDLW	0x80
000e12   0f80     addlw	0x80               	ADDLW	0x80
000e14   e102     bnz	0xe1a                	BNZ	_00182_DS_
000e16   0e01     movlw	0x1                	MOVLW	0x01
000e18   5c02     subwf	0x2, 0, 0          	SUBWF	r0x02, W
                                           _00182_DS_:
000e1a   e338     bnc	0xe8c                	BNC	_00176_DS_
                                           ;	.line	197; main.c	PORTBbits.RB6=1;
000e1c   8c81     bsf	0x81, 0x6, 0         	BSF	_PORTBbits, 6
                                           ;	.line	198; main.c	delay(50);
000e1e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000e20   0e32     movlw	0x32               	MOVLW	0x32
000e22   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e24   ec8b     call	0x1316, 0           	CALL	_delay
000e26   f009
000e28   0e02     movlw	0x2                	MOVLW	0x02
000e2a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	199; main.c	check_bit(ind, i-1);
000e2c   0eff     movlw	0xff               	MOVLW	0xff
000e2e   2402     addwf	0x2, 0, 0          	ADDWF	r0x02, W
000e30   6e04     movwf	0x4, 0             	MOVWF	r0x04
000e32   0eff     movlw	0xff               	MOVLW	0xff
000e34   2003     addwfc	0x3, 0, 0         	ADDWFC	r0x03, W
                                           ; #	MOVWF	r0x05
                                           ; #	MOVF	r0x05, W
000e36   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e38   5004     movf	0x4, 0, 0           	MOVF	r0x04, W
000e3a   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e3c   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000e3e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e40   5000     movf	0, 0, 0             	MOVF	r0x00, W
000e42   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e44   ecf3     call	0xfe6, 0            	CALL	_check_bit
000e46   f007
000e48   0e04     movlw	0x4                	MOVLW	0x04
000e4a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	200; main.c	a =(byte)i;
000e4c   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000e4e   6e04     movwf	0x4, 0             	MOVWF	r0x04
                                           ;	.line	201; main.c	if (a&1) // Chequea la paridad
000e50   a004     btfss	0x4, 0, 0          	BTFSS	r0x04, 0
000e52   d008     bra	0xe64                	BRA	_00170_DS_
                                           ;	.line	202; main.c	desplazar(2);
000e54   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000e56   0e02     movlw	0x2                	MOVLW	0x02
000e58   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e5a   ec3d     call	0x147a, 0           	CALL	_desplazar
000e5c   f00a
000e5e   0e02     movlw	0x2                	MOVLW	0x02
000e60   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
000e62   d007     bra	0xe72                	BRA	_00171_DS_
                                           _00170_DS_:
                                           ;	.line	204; main.c	desplazar(1);
000e64   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000e66   0e01     movlw	0x1                	MOVLW	0x01
000e68   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e6a   ec3d     call	0x147a, 0           	CALL	_desplazar
000e6c   f00a
000e6e   0e02     movlw	0x2                	MOVLW	0x02
000e70   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           _00171_DS_:
                                           ;	.line	205; main.c	delay(50);
000e72   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000e74   0e32     movlw	0x32               	MOVLW	0x32
000e76   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
000e78   ec8b     call	0x1316, 0           	CALL	_delay
000e7a   f009
000e7c   0e02     movlw	0x2                	MOVLW	0x02
000e7e   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	206; main.c	PORTBbits.RB6=0;
000e80   9c81     bcf	0x81, 0x6, 0         	BCF	_PORTBbits, 6
                                           ;	.line	195; main.c	for (i = 8; i > 0; i--)
000e82   0eff     movlw	0xff               	MOVLW	0xff
000e84   2602     addwf	0x2, 0x1, 0        	ADDWF	r0x02, F
000e86   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
000e88   0603     decf	0x3, 0x1, 0         	DECF	r0x03, F
000e8a   d7c1     bra	0xe0e                	BRA	_00172_DS_
                                           _00176_DS_:
000e8c   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000e8e   f004
000e90   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000e92   f003
000e94   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000e96   f002
000e98   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000e9a   f001
000e9c   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000e9e   f000
000ea0   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
000ea2   ffd9
000ea4   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__check_bit	code
                                           _check_bit:
                                           ;	.line	180; main.c	void check_bit(int ind, int pos)  // posicion del bit del 0 al 7
000fe6   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
000fe8   ffe5
000fea   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
000fec   ffd9
000fee   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000ff0   ffe5
000ff2   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000ff4   ffe5
000ff6   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000ff8   ffe5
000ffa   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000ffc   ffe5
000ffe   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
001000   ffe5
001002   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
001004   ffe5
001006   0e02     movlw	0x2                	MOVLW	0x02
001008   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
00100a   f000
00100c   0e03     movlw	0x3                	MOVLW	0x03
00100e   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
001010   f001
001012   0e04     movlw	0x4                	MOVLW	0x04
001014   cfdb     movff	0xfdb, 0x2         	MOVFF	PLUSW2, r0x02
001016   f002
001018   0e05     movlw	0x5                	MOVLW	0x05
00101a   cfdb     movff	0xfdb, 0x3         	MOVFF	PLUSW2, r0x03
00101c   f003
                                           ;	.line	185; main.c	mascara = mascara << pos;
00101e   0e01     movlw	0x1                	MOVLW	0x01
001020   6e04     movwf	0x4, 0             	MOVWF	r0x04
001022   6a05     clrf	0x5, 0              	CLRF	r0x05
001024   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
001026   e00d     bz	0x1042                	BZ	_00161_DS_
001028   e607     bn	0x1038                	BN	_00164_DS_
00102a   6ce8     negf	0xe8, 0             	NEGF	WREG
00102c   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
                                           _00162_DS_:
00102e   3604     rlcf	0x4, 0x1, 0         	RLCF	r0x04, F
001030   3605     rlcf	0x5, 0x1, 0         	RLCF	r0x05, F
001032   0f01     addlw	0x1                	ADDLW	0x01
001034   e3fc     bnc	0x102e               	BNC	_00162_DS_
001036   d005     bra	0x1042               	BRA	_00161_DS_
                                           _00164_DS_:
001038   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
                                           _00163_DS_:
00103a   3205     rrcf	0x5, 0x1, 0         	RRCF	r0x05, F
00103c   3204     rrcf	0x4, 0x1, 0         	RRCF	r0x04, F
00103e   0f01     addlw	0x1                	ADDLW	0x01
001040   e3fc     bnc	0x103a               	BNC	_00163_DS_
                                           _00161_DS_:
001042   5004     movf	0x4, 0, 0           	MOVF	r0x04, W
001044   6e02     movwf	0x2, 0             	MOVWF	r0x02
                                           ;	.line	186; main.c	aux = pagina[ind] & mascara;
001046   0e60     movlw	0x60               	MOVLW	LOW(_pagina)
001048   2600     addwf	0, 0x1, 0          	ADDWF	r0x00, F
00104a   0e00     movlw	0                  	MOVLW	HIGH(_pagina)
00104c   2201     addwfc	0x1, 0x1, 0       	ADDWFC	r0x01, F
00104e   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
001050   ffe9
001052   c001     movff	0x1, 0xfea         	MOVFF	r0x01, FSR0H
001054   ffea
001056   cfef     movff	0xfef, 0           	MOVFF	INDF0, r0x00
001058   f000
00105a   5000     movf	0, 0, 0             	MOVF	r0x00, W
00105c   1602     andwf	0x2, 0x1, 0        	ANDWF	r0x02, F
                                           ; #	MOVF	r0x02, W
                                           ; #	BTFSC	STATUS, 2
                                           ; #	GOTO	_00158_DS_
                                           ; #	CALL	_golpear
                                           ; #; info ==> [localregs] exit begin
                                           
                                           ; #	MOVFF	PREINC1, r0x05
                                           ;	.line	187; main.c	if (aux)
00105e   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
                                           ;	.line	188; main.c	golpear();
001060   a4d8     btfss	0xd8, 0x2, 0       	BTFSS	STATUS, 2
001062   ecb5     call	0x156a, 0           	CALL	_golpear
001064   f00a
001066   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
001068   f005
00106a   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
00106c   f004
00106e   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
001070   f003
001072   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
001074   f002
001076   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
001078   f001
00107a   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
00107c   f000
00107e   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
001080   ffd9
001082   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__volvercarro	code
                                           _volvercarro:
                                           ;	.line	175; main.c	PORTB=0;	
00160a   6a81     clrf	0x81, 0             	CLRF	_PORTB
                                           ;	.line	176; main.c	PORTBbits.RB5 = 1;
00160c   8a81     bsf	0x81, 0x5, 0         	BSF	_PORTBbits, 5
                                           ;	.line	177; main.c	delay(50);	
00160e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001610   0e32     movlw	0x32               	MOVLW	0x32
001612   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001614   ec8b     call	0x1316, 0           	CALL	_delay
001616   f009
001618   0e02     movlw	0x2                	MOVLW	0x02
00161a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
00161c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__rotar	code
                                           _rotar:
                                           ;	.line	162; main.c	void rotar(int cant)
00142e   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
001430   ffe5
001432   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
001434   ffd9
001436   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
001438   ffe5
00143a   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
00143c   ffe5
00143e   0e02     movlw	0x2                	MOVLW	0x02
001440   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
001442   f000
001444   0e03     movlw	0x3                	MOVLW	0x03
001446   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
001448   f001
                                           ;	.line	164; main.c	PORTB=0;
00144a   6a81     clrf	0x81, 0             	CLRF	_PORTB
                                           ;	.line	166; main.c	if (cant==1)
00144c   5000     movf	0, 0, 0             	MOVF	r0x00, W
00144e   0a01     xorlw	0x1                	XORLW	0x01
001450   e102     bnz	0x1456               	BNZ	_00146_DS_
001452   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
001454   e001     bz	0x1458                	BZ	_00147_DS_
                                           _00146_DS_:
001456   d002     bra	0x145c               	BRA	_00141_DS_
                                           _00147_DS_:
                                           ;	.line	167; main.c	PORTBbits.RB3 = 1;
001458   8681     bsf	0x81, 0x3, 0         	BSF	_PORTBbits, 3
00145a   d001     bra	0x145e               	BRA	_00142_DS_
                                           _00141_DS_:
                                           ;	.line	169; main.c	PORTBbits.RB4 = 1;
00145c   8881     bsf	0x81, 0x4, 0         	BSF	_PORTBbits, 4
                                           _00142_DS_:
                                           ;	.line	170; main.c	delay(50);
00145e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
001460   0e32     movlw	0x32               	MOVLW	0x32
001462   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001464   ec8b     call	0x1316, 0           	CALL	_delay
001466   f009
001468   0e02     movlw	0x2                	MOVLW	0x02
00146a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
00146c   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
00146e   f001
001470   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001472   f000
001474   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
001476   ffd9
001478   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__desplazar	code
                                           _desplazar:
                                           ;	.line	150; main.c	void desplazar(int cant)
00147a   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
00147c   ffe5
00147e   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
001480   ffd9
001482   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
001484   ffe5
001486   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
001488   ffe5
00148a   0e02     movlw	0x2                	MOVLW	0x02
00148c   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
00148e   f000
001490   0e03     movlw	0x3                	MOVLW	0x03
001492   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
001494   f001
                                           ;	.line	153; main.c	PORTB=0;
001496   6a81     clrf	0x81, 0             	CLRF	_PORTB
                                           ;	.line	155; main.c	if (cant==1)
001498   5000     movf	0, 0, 0             	MOVF	r0x00, W
00149a   0a01     xorlw	0x1                	XORLW	0x01
00149c   e102     bnz	0x14a2               	BNZ	_00134_DS_
00149e   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
0014a0   e001     bz	0x14a4                	BZ	_00135_DS_
                                           _00134_DS_:
0014a2   d002     bra	0x14a8               	BRA	_00129_DS_
                                           _00135_DS_:
                                           ;	.line	156; main.c	PORTBbits.RB1 = 1;
0014a4   8281     bsf	0x81, 0x1, 0         	BSF	_PORTBbits, 1
0014a6   d001     bra	0x14aa               	BRA	_00130_DS_
                                           _00129_DS_:
                                           ;	.line	158; main.c	PORTBbits.RB2 = 1;
0014a8   8481     bsf	0x81, 0x2, 0         	BSF	_PORTBbits, 2
                                           _00130_DS_:
                                           ;	.line	159; main.c	delay(50);
0014aa   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
0014ac   0e32     movlw	0x32               	MOVLW	0x32
0014ae   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0014b0   ec8b     call	0x1316, 0           	CALL	_delay
0014b2   f009
0014b4   0e02     movlw	0x2                	MOVLW	0x02
0014b6   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
0014b8   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
0014ba   f001
0014bc   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0014be   f000
0014c0   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
0014c2   ffd9
0014c4   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__check_driver	code
                                           _check_driver:
                                           ;	.line	147; main.c	PORTB = 0xff;
001648   0eff     movlw	0xff               	MOVLW	0xff
00164a   6881     setf	0x81, 0             	SETF	_PORTB
00164c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__golpear	code
                                           _golpear:
                                           ;	.line	138; main.c	PERCUTOR = 0;
00156a   9283     bcf	0x83, 0x1, 0         	BCF	_PORTDbits, 1
                                           ;	.line	139; main.c	delay(500);
00156c   0e01     movlw	0x1                	MOVLW	0x01
00156e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001570   0ef4     movlw	0xf4               	MOVLW	0xf4
001572   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001574   ec8b     call	0x1316, 0           	CALL	_delay
001576   f009
001578   0e02     movlw	0x2                	MOVLW	0x02
00157a   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	140; main.c	PERCUTOR = 1;
00157c   8283     bsf	0x83, 0x1, 0         	BSF	_PORTDbits, 1
                                           ;	.line	141; main.c	delay(5000);
00157e   0e13     movlw	0x13               	MOVLW	0x13
001580   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001582   0e88     movlw	0x88               	MOVLW	0x88
001584   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
001586   ec8b     call	0x1316, 0           	CALL	_delay
001588   f009
00158a   0e02     movlw	0x2                	MOVLW	0x02
00158c   26e1     addwf	0xe1, 0x1, 0       	ADDWF	FSR1L, F
                                           ;	.line	142; main.c	PERCUTOR = 0;
00158e   9283     bcf	0x83, 0x1, 0         	BCF	_PORTDbits, 1
001590   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__delay	code
                                           _delay:
                                           ;	.line	124; main.c	void delay(int ms)
001316   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
001318   ffe5
00131a   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
00131c   ffd9
00131e   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
001320   ffe5
001322   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
001324   ffe5
001326   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
001328   ffe5
00132a   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
00132c   ffe5
00132e   0e02     movlw	0x2                	MOVLW	0x02
001330   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
001332   f000
001334   0e03     movlw	0x3                	MOVLW	0x03
001336   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
001338   f001
                                           _00109_DS_:
                                           ;	.line	128; main.c	while(ms--)
00133a   c000     movff	0, 0x2             	MOVFF	r0x00, r0x02
00133c   f002
00133e   c001     movff	0x1, 0x3           	MOVFF	r0x01, r0x03
001340   f003
001342   0eff     movlw	0xff               	MOVLW	0xff
001344   2600     addwf	0, 0x1, 0          	ADDWF	r0x00, F
001346   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
001348   0601     decf	0x1, 0x1, 0         	DECF	r0x01, F
00134a   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
00134c   1003     iorwf	0x3, 0, 0          	IORWF	r0x03, W
00134e   e00b     bz	0x1366                	BZ	_00115_DS_
                                           ;	.line	129; main.c	for(i=0;i<100;i++); // Estos nmeros son ciclos sucifientes para generar retardo
001350   0e64     movlw	0x64               	MOVLW	0x64
001352   6e02     movwf	0x2, 0             	MOVWF	r0x02
001354   6a03     clrf	0x3, 0              	CLRF	r0x03
                                           _00114_DS_:
001356   0eff     movlw	0xff               	MOVLW	0xff
001358   2602     addwf	0x2, 0x1, 0        	ADDWF	r0x02, F
00135a   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
00135c   0603     decf	0x3, 0x1, 0         	DECF	r0x03, F
00135e   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
001360   1003     iorwf	0x3, 0, 0          	IORWF	r0x03, W
001362   e1f9     bnz	0x1356               	BNZ	_00114_DS_
001364   d7ea     bra	0x133a               	BRA	_00109_DS_
                                           _00115_DS_:
001366   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
001368   f003
00136a   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
00136c   f002
00136e   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
001370   f001
001372   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001374   f000
001376   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
001378   ffd9
00137a   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_main__UserInit	code
                                           _UserInit:
                                           ;	.line	96; main.c	TRISA &= 0xEF;
0015b4   9892     bcf	0x92, 0x4, 0         	BCF	_TRISA, 4
                                           ;	.line	99; main.c	ADCON0 = 0xFF;
0015b6   0eff     movlw	0xff               	MOVLW	0xff
0015b8   6ec2     movwf	0xc2, 0            	MOVWF	_ADCON0
                                           	;	VOLATILE READ - BEGIN
0015ba   5093     movf	0x93, 0, 0          	MOVF	_TRISB, W
                                           	;	VOLATILE READ - END
0015bc   6a93     clrf	0x93, 0             	CLRF	_TRISB
                                           ;	.line	101; main.c	INTCON = 0;
0015be   6af2     clrf	0xf2, 0             	CLRF	_INTCON
                                           ;	.line	102; main.c	INTCON2 = 0;
0015c0   6af1     clrf	0xf1, 0             	CLRF	_INTCON2
                                           ;	.line	103; main.c	TRISE = 0;
0015c2   6a96     clrf	0x96, 0             	CLRF	_TRISE
                                           ;	.line	104; main.c	TRISB = 0;
0015c4   6a93     clrf	0x93, 0             	CLRF	_TRISB
                                           ;	.line	105; main.c	TRISD = 0xc;
0015c6   0e0c     movlw	0xc                	MOVLW	0x0c
0015c8   6e95     movwf	0x95, 0            	MOVWF	_TRISD
                                           ;	.line	116; main.c	PORTE = 0;
0015ca   6a84     clrf	0x84, 0             	CLRF	_PORTE
                                           ;	.line	117; main.c	PORTB = 0xff; 
0015cc   0eff     movlw	0xff               	MOVLW	0xff
0015ce   6e81     movwf	0x81, 0            	MOVWF	_PORTB
                                           ;	.line	118; main.c	PORTD = 0;
0015d0   6a83     clrf	0x83, 0             	CLRF	_PORTD
0015d2   0012     return	0                 	RETURN	
                                           
                                           
                                           
                                           ; Statistics:
                                           ; code size:	 2410 (0x096a) bytes ( 1.84%)
                                           ;           	 1205 (0x04b5) words
                                           ; udata size:	  200 (0x00c8) bytes (11.16%)
                                           ; access size:	   15 (0x000f) bytes
                                           
                                           
                                           	end
                                           ;--------------------------------------------------------
                                           ; File Created by SDCC : free open source ANSI-C Compiler
                                           ; Version 2.7.0 #4818 (Jan 18 2008)
                                           ; This file generated Wed Apr 30 19:44:14 2008
                                           ;--------------------------------------------------------
                                           ; PIC16 port for the Microchip 16-bit core micros
                                           ;--------------------------------------------------------
                                           	list	p=18f4550
                                           
                                           	radix dec
                                           
                                           ;--------------------------------------------------------
                                           ; public variables in this module
                                           ;--------------------------------------------------------
                                           	global _deviceAddress
                                           	global _BulkIn
                                           	global _BulkOut
                                           	global _EnableUSBModule
                                           	global _ProcessUSBTransactions
                                           	global _deviceState
                                           	global _remoteWakeup
                                           	global _selfPowered
                                           	global _currentConfiguration
                                           	global _ctrlTransferStage
                                           	global _requestHandled
                                           	global _outPtr
                                           	global _inPtr
                                           	global _wCount
                                           	global _RxLen
                                           	global _ep0Bo
                                           	global _ep0Bi
                                           	global _ep1Bo
                                           	global _ep1Bi
                                           	global _SetupPacket
                                           	global _controlTransferBuffer
                                           	global _RxBuffer
                                           	global _TxBuffer
                                           	global _InitEndpoint
                                           	global _ProcessStandardRequest
                                           	global _InDataStage
                                           	global _OutDataStage
                                           	global _SetupStage
                                           	global _WaitForSetupStage
                                           	global _ProcessControlTransfer
                                           	global _UnSuspend
                                           	global _StartOfFrame
                                           	global _Stall
                                           	global _BusReset
                                           	global _deviceDescriptor
                                           	global _configDescriptor
                                           	global _stringDescriptor0
                                           	global _stringDescriptor1
                                           	global _stringDescriptor2
                                           	global _dataEEPROM
                                           
                                           ;--------------------------------------------------------
                                           ; extern variables in this module
                                           ;--------------------------------------------------------
                                           	extern __gptrget1
                                           	extern __gptrput1
                                           	extern _SPPDATAbits
                                           	extern _SPPCFGbits
                                           	extern _SPPEPSbits
                                           	extern _SPPCONbits
                                           	extern _UFRMLbits
                                           	extern _UFRMHbits
                                           	extern _UIRbits
                                           	extern _UIEbits
                                           	extern _UEIRbits
                                           	extern _UEIEbits
                                           	extern _USTATbits
                                           	extern _UCONbits
                                           	extern _UADDRbits
                                           	extern _UCFGbits
                                           	extern _UEP0bits
                                           	extern _UEP1bits
                                           	extern _UEP2bits
                                           	extern _UEP3bits
                                           	extern _UEP4bits
                                           	extern _UEP5bits
                                           	extern _UEP6bits
                                           	extern _UEP7bits
                                           	extern _UEP8bits
                                           	extern _UEP9bits
                                           	extern _UEP10bits
                                           	extern _UEP11bits
                                           	extern _UEP12bits
                                           	extern _UEP13bits
                                           	extern _UEP14bits
                                           	extern _UEP15bits
                                           	extern _PORTAbits
                                           	extern _PORTBbits
                                           	extern _PORTCbits
                                           	extern _PORTDbits
                                           	extern _PORTEbits
                                           	extern _LATAbits
                                           	extern _LATBbits
                                           	extern _LATCbits
                                           	extern _LATDbits
                                           	extern _LATEbits
                                           	extern _TRISAbits
                                           	extern _TRISBbits
                                           	extern _TRISCbits
                                           	extern _TRISDbits
                                           	extern _TRISEbits
                                           	extern _OSCTUNEbits
                                           	extern _PIE1bits
                                           	extern _PIR1bits
                                           	extern _IPR1bits
                                           	extern _PIE2bits
                                           	extern _PIR2bits
                                           	extern _IPR2bits
                                           	extern _EECON1bits
                                           	extern _RCSTAbits
                                           	extern _TXSTAbits
                                           	extern _T3CONbits
                                           	extern _CMCONbits
                                           	extern _CVRCONbits
                                           	extern _ECCP1ASbits
                                           	extern _ECCP1DELbits
                                           	extern _BAUDCONbits
                                           	extern _CCP2CONbits
                                           	extern _CCP1CONbits
                                           	extern _ADCON2bits
                                           	extern _ADCON1bits
                                           	extern _ADCON0bits
                                           	extern _SSPCON2bits
                                           	extern _SSPCON1bits
                                           	extern _SSPSTATbits
                                           	extern _T2CONbits
                                           	extern _T1CONbits
                                           	extern _RCONbits
                                           	extern _WDTCONbits
                                           	extern _HLVDCONbits
                                           	extern _OSCCONbits
                                           	extern _T0CONbits
                                           	extern _STATUSbits
                                           	extern _FSR2Hbits
                                           	extern _BSRbits
                                           	extern _FSR1Hbits
                                           	extern _FSR0Hbits
                                           	extern _INTCON3bits
                                           	extern _INTCON2bits
                                           	extern _INTCONbits
                                           	extern _TBLPTRUbits
                                           	extern _PCLATHbits
                                           	extern _PCLATUbits
                                           	extern _STKPTRbits
                                           	extern _TOSUbits
                                           	extern _stdin
                                           	extern _stdout
                                           	extern _RxBuff
                                           	extern _SPPDATA
                                           	extern _SPPCFG
                                           	extern _SPPEPS
                                           	extern _SPPCON
                                           	extern _UFRML
                                           	extern _UFRMH
                                           	extern _UIR
                                           	extern _UIE
                                           	extern _UEIR
                                           	extern _UEIE
                                           	extern _USTAT
                                           	extern _UCON
                                           	extern _UADDR
                                           	extern _UCFG
                                           	extern _UEP0
                                           	extern _UEP1
                                           	extern _UEP2
                                           	extern _UEP3
                                           	extern _UEP4
                                           	extern _UEP5
                                           	extern _UEP6
                                           	extern _UEP7
                                           	extern _UEP8
                                           	extern _UEP9
                                           	extern _UEP10
                                           	extern _UEP11
                                           	extern _UEP12
                                           	extern _UEP13
                                           	extern _UEP14
                                           	extern _UEP15
                                           	extern _PORTA
                                           	extern _PORTB
                                           	extern _PORTC
                                           	extern _PORTD
                                           	extern _PORTE
                                           	extern _LATA
                                           	extern _LATB
                                           	extern _LATC
                                           	extern _LATD
                                           	extern _LATE
                                           	extern _TRISA
                                           	extern _TRISB
                                           	extern _TRISC
                                           	extern _TRISD
                                           	extern _TRISE
                                           	extern _OSCTUNE
                                           	extern _PIE1
                                           	extern _PIR1
                                           	extern _IPR1
                                           	extern _PIE2
                                           	extern _PIR2
                                           	extern _IPR2
                                           	extern _EECON1
                                           	extern _EECON2
                                           	extern _EEDATA
                                           	extern _EEADR
                                           	extern _RCSTA
                                           	extern _TXSTA
                                           	extern _TXREG
                                           	extern _RCREG
                                           	extern _SPBRG
                                           	extern _SPBRGH
                                           	extern _T3CON
                                           	extern _TMR3L
                                           	extern _TMR3H
                                           	extern _CMCON
                                           	extern _CVRCON
                                           	extern _ECCP1AS
                                           	extern _ECCP1DEL
                                           	extern _BAUDCON
                                           	extern _CCP2CON
                                           	extern _CCPR2L
                                           	extern _CCPR2H
                                           	extern _CCP1CON
                                           	extern _CCPR1L
                                           	extern _CCPR1H
                                           	extern _ADCON2
                                           	extern _ADCON1
                                           	extern _ADCON0
                                           	extern _ADRESL
                                           	extern _ADRESH
                                           	extern _SSPCON2
                                           	extern _SSPCON1
                                           	extern _SSPSTAT
                                           	extern _SSPADD
                                           	extern _SSPBUF
                                           	extern _T2CON
                                           	extern _PR2
                                           	extern _TMR2
                                           	extern _T1CON
                                           	extern _TMR1L
                                           	extern _TMR1H
                                           	extern _RCON
                                           	extern _WDTCON
                                           	extern _HLVDCON
                                           	extern _OSCCON
                                           	extern _T0CON
                                           	extern _TMR0L
                                           	extern _TMR0H
                                           	extern _STATUS
                                           	extern _FSR2L
                                           	extern _FSR2H
                                           	extern _PLUSW2
                                           	extern _PREINC2
                                           	extern _POSTDEC2
                                           	extern _POSTINC2
                                           	extern _INDF2
                                           	extern _BSR
                                           	extern _FSR1L
                                           	extern _FSR1H
                                           	extern _PLUSW1
                                           	extern _PREINC1
                                           	extern _POSTDEC1
                                           	extern _POSTINC1
                                           	extern _INDF1
                                           	extern _WREG
                                           	extern _FSR0L
                                           	extern _FSR0H
                                           	extern _PLUSW0
                                           	extern _PREINC0
                                           	extern _POSTDEC0
                                           	extern _POSTINC0
                                           	extern _INDF0
                                           	extern _INTCON3
                                           	extern _INTCON2
                                           	extern _INTCON
                                           	extern _PRODL
                                           	extern _PRODH
                                           	extern _TABLAT
                                           	extern _TBLPTRL
                                           	extern _TBLPTRH
                                           	extern _TBLPTRU
                                           	extern _PCL
                                           	extern _PCLATH
                                           	extern _PCLATU
                                           	extern _STKPTR
                                           	extern _TOSL
                                           	extern _TOSH
                                           	extern _TOSU
                                           ;--------------------------------------------------------
                                           ;	Equates to used internal registers
                                           ;--------------------------------------------------------
                                           STATUS	equ	0xfd8
                                           WREG	equ	0xfe8
                                           TBLPTRL	equ	0xff6
                                           TBLPTRH	equ	0xff7
                                           TBLPTRU	equ	0xff8
                                           TABLAT	equ	0xff5
                                           FSR0L	equ	0xfe9
                                           FSR0H	equ	0xfea
                                           FSR1L	equ	0xfe1
                                           FSR2L	equ	0xfd9
                                           INDF0	equ	0xfef
                                           POSTDEC1	equ	0xfe5
                                           PREINC1	equ	0xfe4
                                           PLUSW2	equ	0xfdb
                                           PRODL	equ	0xff3
                                           PRODH	equ	0xff4
                                           
                                           
                                           ; Internal registers
                                           .registers	udata_ovr	0x0000
                                           r0x00	res	1
                                           r0x01	res	1
                                           r0x02	res	1
                                           r0x03	res	1
                                           r0x04	res	1
                                           r0x05	res	1
                                           r0x06	res	1
                                           r0x07	res	1
                                           r0x08	res	1
                                           r0x09	res	1
                                           
                                           
                                           usbram5	udata
                                           _RxBuffer	res	64
                                           _TxBuffer	res	64
                                           _SetupPacket	res	64
                                           _controlTransferBuffer	res	64
                                           
                                           udata_usb_0	udata
                                           _deviceAddress	res	1
                                           
                                           udata_usb_1	udata
                                           _RxLen	res	1
                                           
                                           udata_usb_2	udata
                                           _requestHandled	res	1
                                           
                                           udata_usb_3	udata
                                           _outPtr	res	3
                                           
                                           udata_usb_4	udata
                                           _wCount	res	2
                                           
                                           udata_usb_5	udata
                                           _inPtr	res	3
                                           
                                           udata_usb_6	udata
                                           _selfPowered	res	1
                                           
                                           udata_usb_7	udata
                                           _remoteWakeup	res	1
                                           
                                           udata_usb_8	udata
                                           _deviceState	res	1
                                           
                                           udata_usb_9	udata
                                           _currentConfiguration	res	1
                                           
                                           udata_usb_10	udata
                                           _ctrlTransferStage	res	1
                                           
                                           
                                           ustat_usb_00	udata	0X0400
                                           _ep0Bo	res	4
                                           _ep0Bi	res	4
                                           _ep1Bo	res	4
                                           _ep1Bi	res	4
                                           
                                           ;--------------------------------------------------------
                                           ; global & static initialisations
                                           ;--------------------------------------------------------
                                           ; ; Starting pCode block for absolute Ival
                                           S_usb__dataEEPROM	code	0XF00000
                                           _dataEEPROM:
f00000   0000     nop                      	DB	0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00
f00002   0001     dw	0x1  ;unknown opcode  
f00004   0002     dw	0x2  ;unknown opcode  
f00006   0003     sleep                    
f00008   0004     clrwdt                   
f0000a   0005     push                     
f0000c   0006     pop                      	DB	0x06, 0x00, 0x07, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00
f0000e   0007     daw                      
f00010   0030     dw	0x30  ;unknown opcode 
f00012   0031     dw	0x31  ;unknown opcode 
f00014   0032     dw	0x32  ;unknown opcode 
f00016   0033     dw	0x33  ;unknown opcode 
f00018   0034     dw	0x34  ;unknown opcode 	DB	0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00
f0001a   0035     dw	0x35  ;unknown opcode 
f0001c   0036     dw	0x36  ;unknown opcode 
f0001e   0037     dw	0x37  ;unknown opcode 
f00020   0038     dw	0x38  ;unknown opcode 
f00022   0039     dw	0x39  ;unknown opcode 
f00024   0061     dw	0x61  ;unknown opcode 	DB	0x61, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00, 0x65, 0x00, 0x66, 0x00
f00026   0062     dw	0x62  ;unknown opcode 
f00028   0063     dw	0x63  ;unknown opcode 
f0002a   0064     dw	0x64  ;unknown opcode 
f0002c   0065     dw	0x65  ;unknown opcode 
f0002e   0066     dw	0x66  ;unknown opcode 
                                           
                                           ; I code from now on!
                                           ; ; Starting pCode block
                                           S_usb__ProcessUSBTransactions	code
                                           _ProcessUSBTransactions:
                                           ;	.line	803; usb.c	void ProcessUSBTransactions(void)
0012ac   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0012ae   ffe5
                                           ; #	MOVF	_deviceState, W, B
                                           ; #	BTFSS	STATUS, 2
                                           ; #	GOTO	_00499_DS_
                                           ; #	GOTO	_00525_DS_
                                           ; #	BTFSS	_UIRbits, 2
0012b0   0100     movlb	0                  	BANKSEL	_deviceState
                                           ;	.line	806; usb.c	if(deviceState == DETACHED)
0012b2   51fb     movf	0xfb, 0, 0x1        	MOVF	_deviceState, W, B
                                           ;	.line	807; usb.c	return;
0012b4   e02d     bz	0x1310                	BZ	_00525_DS_
                                           ;	.line	810; usb.c	if(UIRbits.ACTVIF && UIEbits.ACTVIE)
0012b6   a468     btfss	0x68, 0x2, 0       	BTFSS	_UIRbits, 2
                                           ; #	GOTO	_00501_DS_
                                           ; #	BTFSS	_UIEbits, 2
                                           ; #	GOTO	_00501_DS_
                                           ; #	CALL	_UnSuspend
                                           ; #	CLRF	r0x00
                                           ;	.line	811; usb.c	UnSuspend();
0012b8   d003     bra	0x12c0               	BRA	_00501_DS_
                                           ;	.line	814; usb.c	if(UCONbits.SUSPND == 1)
0012ba   b469     btfsc	0x69, 0x2, 0       	BTFSC	_UIEbits, 2
0012bc   ec20     call	0x1640, 0           	CALL	_UnSuspend
0012be   f00b
                                           _00501_DS_:
0012c0   6a00     clrf	0, 0                	CLRF	r0x00
0012c2   b26d     btfsc	0x6d, 0x1, 0       	BTFSC	_UCONbits, 1
0012c4   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
0012c6   5000     movf	0, 0, 0             	MOVF	r0x00, W
0012c8   0a01     xorlw	0x1                	XORLW	0x01
                                           ;	.line	815; usb.c	return;
0012ca   e022     bz	0x1310                	BZ	_00525_DS_
                                           ;	.line	818; usb.c	if (UIRbits.URSTIF && UIEbits.URSTIE)
0012cc   a068     btfss	0x68, 0, 0         	BTFSS	_UIRbits, 0
                                           ; #	GOTO	_00506_DS_
                                           ; #	BTFSS	_UIEbits, 0
                                           ; #	GOTO	_00506_DS_
                                           ; #	CALL	_BusReset
                                           ; #	BTFSS	_UIRbits, 4
                                           ;	.line	819; usb.c	BusReset();
0012ce   d003     bra	0x12d6               	BRA	_00506_DS_
                                           ;	.line	821; usb.c	if (UIRbits.IDLEIF && UIEbits.IDLEIE)
0012d0   b069     btfsc	0x69, 0, 0         	BTFSC	_UIEbits, 0
0012d2   ec63     call	0x14c6, 0           	CALL	_BusReset
0012d4   f00a
                                           _00506_DS_:
0012d6   a868     btfss	0x68, 0x4, 0       	BTFSS	_UIRbits, 4
0012d8   d007     bra	0x12e8               	BRA	_00512_DS_
0012da   a869     btfss	0x69, 0x4, 0       	BTFSS	_UIEbits, 4
0012dc   d005     bra	0x12e8               	BRA	_00512_DS_
                                           ;	.line	824; usb.c	if (UIRbits.SOFIF && UIEbits.SOFIE)
0012de   ac68     btfss	0x68, 0x6, 0       	BTFSS	_UIRbits, 6
                                           ; #	GOTO	_00512_DS_
                                           ; #	BTFSS	_UIEbits, 6
                                           ; #	GOTO	_00512_DS_
                                           ; #	CALL	_StartOfFrame
                                           ; #	BTFSS	_UIRbits, 5
                                           ;	.line	825; usb.c	StartOfFrame();
0012e0   d003     bra	0x12e8               	BRA	_00512_DS_
                                           ;	.line	827; usb.c	if (UIRbits.STALLIF && UIEbits.STALLIE)
0012e2   bc69     btfsc	0x69, 0x6, 0       	BTFSC	_UIEbits, 6
0012e4   ec29     call	0x1652, 0           	CALL	_StartOfFrame
0012e6   f00b
                                           _00512_DS_:
0012e8   aa68     btfss	0x68, 0x5, 0       	BTFSS	_UIRbits, 5
                                           ; #	GOTO	_00515_DS_
                                           ; #	BTFSS	_UIEbits, 5
                                           ; #	GOTO	_00515_DS_
                                           ; #	CALL	_Stall
                                           ; #	BTFSS	_UIRbits, 1
                                           ;	.line	828; usb.c	Stall();
0012ea   d003     bra	0x12f2               	BRA	_00515_DS_
                                           ;	.line	830; usb.c	if (UIRbits.UERRIF && UIEbits.UERRIE)
0012ec   ba69     btfsc	0x69, 0x5, 0       	BTFSC	_UIEbits, 5
0012ee   ecea     call	0x15d4, 0           	CALL	_Stall
0012f0   f00a
                                           _00515_DS_:
0012f2   a268     btfss	0x68, 0x1, 0       	BTFSS	_UIRbits, 1
                                           ; #	GOTO	_00518_DS_
                                           ; #	BTFSS	_UIEbits, 1
                                           ; #	GOTO	_00518_DS_
                                           ; #	BCF	_UIRbits, 1
                                           ; #	MOVLW	0x03
                                           ;	.line	834; usb.c	UIRbits.UERRIF = 0;
0012f4   d002     bra	0x12fa               	BRA	_00518_DS_
                                           ;	.line	837; usb.c	if (deviceState < DEFAULT)
0012f6   b269     btfsc	0x69, 0x1, 0       	BTFSC	_UIEbits, 1
0012f8   9268     bcf	0x68, 0x1, 0         	BCF	_UIRbits, 1
                                           _00518_DS_:
0012fa   0e03     movlw	0x3                	MOVLW	0x03
                                           ; #	SUBWF	_deviceState, W, B
                                           ; #	BTFSC	STATUS, 0
                                           ; #	GOTO	_00521_DS_
                                           ; #	GOTO	_00525_DS_
                                           ; #	BTFSS	_UIRbits, 3
0012fc   0100     movlb	0                  	BANKSEL	_deviceState
                                           ;	.line	838; usb.c	return;
0012fe   5dfb     subwf	0xfb, 0, 0x1       	SUBWF	_deviceState, W, B
                                           ;	.line	841; usb.c	if(UIRbits.TRNIF && UIEbits.TRNIE)
001300   e307     bnc	0x1310               	BNC	_00525_DS_
001302   a668     btfss	0x68, 0x3, 0       	BTFSS	_UIRbits, 3
001304   d005     bra	0x1310               	BRA	_00525_DS_
001306   a669     btfss	0x69, 0x3, 0       	BTFSS	_UIEbits, 3
001308   d003     bra	0x1310               	BRA	_00525_DS_
                                           ;	.line	843; usb.c	ProcessControlTransfer();
00130a   ec42     call	0x1084, 0           	CALL	_ProcessControlTransfer
00130c   f008
                                           ;	.line	845; usb.c	UIRbits.TRNIF = 0;
00130e   9668     bcf	0x68, 0x3, 0         	BCF	_UIRbits, 3
                                           _00525_DS_:
001310   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001312   f000
001314   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__BusReset	code
                                           _BusReset:
                                           ;	.line	774; usb.c	void BusReset()
0014c6   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0014c8   ffe5
                                           ;	.line	776; usb.c	UEIR  = 0x00;
0014ca   6a6a     clrf	0x6a, 0             	CLRF	_UEIR
                                           ;	.line	777; usb.c	UIR   = 0x00;
0014cc   6a68     clrf	0x68, 0             	CLRF	_UIR
                                           ;	.line	778; usb.c	UEIE  = 0x9f;
0014ce   0e9f     movlw	0x9f               	MOVLW	0x9f
0014d0   6e6b     movwf	0x6b, 0            	MOVWF	_UEIE
                                           ;	.line	779; usb.c	UIE   = 0x7b;
0014d2   0e7b     movlw	0x7b               	MOVLW	0x7b
0014d4   6e69     movwf	0x69, 0            	MOVWF	_UIE
                                           ;	.line	780; usb.c	UADDR = 0x00;
0014d6   6a6e     clrf	0x6e, 0             	CLRF	_UADDR
                                           ;	.line	783; usb.c	UEP0 = 0x16;
0014d8   0e16     movlw	0x16               	MOVLW	0x16
0014da   6e70     movwf	0x70, 0            	MOVWF	_UEP0
                                           _00485_DS_:
                                           ;	.line	786; usb.c	while (UIRbits.TRNIF == 1)
0014dc   6a00     clrf	0, 0                	CLRF	r0x00
0014de   b668     btfsc	0x68, 0x3, 0       	BTFSC	_UIRbits, 3
0014e0   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
0014e2   5000     movf	0, 0, 0             	MOVF	r0x00, W
0014e4   0a01     xorlw	0x1                	XORLW	0x01
0014e6   e102     bnz	0x14ec               	BNZ	_00487_DS_
                                           ;	.line	787; usb.c	UIRbits.TRNIF = 0;
0014e8   9668     bcf	0x68, 0x3, 0         	BCF	_UIRbits, 3
0014ea   d7f8     bra	0x14dc               	BRA	_00485_DS_
                                           _00487_DS_:
                                           ;	.line	790; usb.c	UCONbits.PKTDIS = 0;
0014ec   986d     bcf	0x6d, 0x4, 0         	BCF	_UCONbits, 4
                                           ;	.line	793; usb.c	WaitForSetupStage();
0014ee   ec85     call	0x150a, 0           	CALL	_WaitForSetupStage
0014f0   f00a
0014f2   0100     movlb	0                  	BANKSEL	_remoteWakeup
                                           ;	.line	794; usb.c	remoteWakeup = 0;         // Remote wakeup esta apagado por defecto
0014f4   6bfa     clrf	0xfa, 0x1           	CLRF	_remoteWakeup, B
0014f6   0100     movlb	0                  	BANKSEL	_selfPowered
                                           ;	.line	795; usb.c	selfPowered = 0;          // Self powered esta apagado por defecto
0014f8   6bf9     clrf	0xf9, 0x1           	CLRF	_selfPowered, B
0014fa   0100     movlb	0                  	BANKSEL	_currentConfiguration
                                           ;	.line	796; usb.c	currentConfiguration = 0; // Borra la configuracion activa
0014fc   6bfc     clrf	0xfc, 0x1           	CLRF	_currentConfiguration, B
                                           ;	.line	797; usb.c	deviceState = DEFAULT;
0014fe   0e03     movlw	0x3                	MOVLW	0x03
001500   0100     movlb	0                  	BANKSEL	_deviceState
001502   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
001504   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001506   f000
001508   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__Stall	code
                                           _Stall:
                                           ;	.line	763; usb.c	void Stall(void)
0015d4   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0015d6   ffe5
                                           ;	.line	765; usb.c	if(UEP0bits.EPSTALL == 1)
0015d8   6a00     clrf	0, 0                	CLRF	r0x00
0015da   b070     btfsc	0x70, 0, 0         	BTFSC	_UEP0bits, 0
0015dc   2a00     incf	0, 0x1, 0           	INCF	r0x00, F
0015de   5000     movf	0, 0, 0             	MOVF	r0x00, W
0015e0   0a01     xorlw	0x1                	XORLW	0x01
0015e2   e103     bnz	0x15ea               	BNZ	_00475_DS_
                                           ;	.line	768; usb.c	WaitForSetupStage();
0015e4   ec85     call	0x150a, 0           	CALL	_WaitForSetupStage
0015e6   f00a
                                           ;	.line	769; usb.c	UEP0bits.EPSTALL = 0;
0015e8   9070     bcf	0x70, 0, 0           	BCF	_UEP0bits, 0
                                           _00475_DS_:
                                           ;	.line	771; usb.c	UIRbits.STALLIF = 0;
0015ea   9a68     bcf	0x68, 0x5, 0         	BCF	_UIRbits, 5
0015ec   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0015ee   f000
0015f0   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__StartOfFrame	code
                                           _StartOfFrame:
                                           ;	.line	759; usb.c	UIRbits.SOFIF = 0;
001652   9c68     bcf	0x68, 0x6, 0         	BCF	_UIRbits, 6
001654   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__UnSuspend	code
                                           _UnSuspend:
                                           ;	.line	749; usb.c	UCONbits.SUSPND = 0;
001640   926d     bcf	0x6d, 0x1, 0         	BCF	_UCONbits, 1
                                           ;	.line	750; usb.c	UIEbits.ACTVIE = 0;
001642   9469     bcf	0x69, 0x2, 0         	BCF	_UIEbits, 2
                                           ;	.line	751; usb.c	UIRbits.ACTVIF = 0;
001644   9468     bcf	0x68, 0x2, 0         	BCF	_UIRbits, 2
001646   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__EnableUSBModule	code
                                           _EnableUSBModule:
                                           ;	.line	726; usb.c	if(UCONbits.USBEN == 0)
00153e   b66d     btfsc	0x6d, 0x3, 0       	BTFSC	_UCONbits, 3
001540   d006     bra	0x154e               	BRA	_00451_DS_
                                           ;	.line	728; usb.c	UCON = 0;
001542   6a6d     clrf	0x6d, 0             	CLRF	_UCON
                                           ;	.line	729; usb.c	UIE = 0;
001544   6a69     clrf	0x69, 0             	CLRF	_UIE
                                           ;	.line	730; usb.c	UCONbits.USBEN = 1;
001546   866d     bsf	0x6d, 0x3, 0         	BSF	_UCONbits, 3
                                           ;	.line	731; usb.c	deviceState = ATTACHED;
001548   0e01     movlw	0x1                	MOVLW	0x01
00154a   0100     movlb	0                  	BANKSEL	_deviceState
00154c   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
                                           _00451_DS_:
00154e   0100     movlb	0                  	BANKSEL	_deviceState
                                           ;	.line	736; usb.c	if ((deviceState == ATTACHED) && !UCONbits.SE0)
001550   51fb     movf	0xfb, 0, 0x1        	MOVF	_deviceState, W, B
001552   0a01     xorlw	0x1                	XORLW	0x01
001554   e109     bnz	0x1568               	BNZ	_00455_DS_
001556   ba6d     btfsc	0x6d, 0x5, 0       	BTFSC	_UCONbits, 5
001558   d007     bra	0x1568               	BRA	_00455_DS_
                                           ;	.line	738; usb.c	UIR = 0;
00155a   6a68     clrf	0x68, 0             	CLRF	_UIR
                                           ;	.line	739; usb.c	UIE = 0;
00155c   6a69     clrf	0x69, 0             	CLRF	_UIE
                                           ;	.line	740; usb.c	UIEbits.URSTIE = 1;
00155e   8069     bsf	0x69, 0, 0           	BSF	_UIEbits, 0
                                           ;	.line	741; usb.c	UIEbits.IDLEIE = 1;
001560   8869     bsf	0x69, 0x4, 0         	BSF	_UIEbits, 4
                                           ;	.line	742; usb.c	deviceState = POWERED;
001562   0e02     movlw	0x2                	MOVLW	0x02
001564   0100     movlb	0                  	BANKSEL	_deviceState
001566   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
                                           _00455_DS_:
001568   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__ProcessControlTransfer	code
                                           _ProcessControlTransfer:
                                           ;	.line	655; usb.c	void ProcessControlTransfer(void)
001084   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
001086   ffe5
                                           ;	.line	657; usb.c	if (USTAT == 0)
001088   506c     movf	0x6c, 0, 0          	MOVF	_USTAT, W
00108a   e122     bnz	0x10d0               	BNZ	_00421_DS_
                                           ;	.line	660; usb.c	byte PID = (ep0Bo.Stat & 0x3C) >> 2; // Extrae el PID del medio de BD0STAT
00108c   0e3c     movlw	0x3c               	MOVLW	0x3c
00108e   0104     movlb	0x4                	BANKSEL	_ep0Bo
001090   1500     andwf	0, 0, 0x1          	ANDWF	_ep0Bo, W, B
001092   6e00     movwf	0, 0               	MOVWF	r0x00
001094   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
001096   3000     rrcf	0, 0, 0             	RRCF	r0x00, W
001098   6e00     movwf	0, 0               	MOVWF	r0x00
00109a   90d8     bcf	0xd8, 0, 0           	BCF	STATUS, 0
00109c   3200     rrcf	0, 0x1, 0           	RRCF	r0x00, F
                                           ;	.line	662; usb.c	if (PID == 0x0D)
00109e   5000     movf	0, 0, 0             	MOVF	r0x00, W
0010a0   0a0d     xorlw	0xd                	XORLW	0x0d
0010a2   e103     bnz	0x10aa               	BNZ	_00405_DS_
                                           ;	.line	664; usb.c	SetupStage();
0010a4   ec32     call	0xa64, 0            	CALL	_SetupStage
0010a6   f005
0010a8   d035     bra	0x1114               	BRA	_00423_DS_
                                           _00405_DS_:
0010aa   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
                                           ;	.line	665; usb.c	else if (ctrlTransferStage == DATA_OUT_STAGE)
0010ac   51fd     movf	0xfd, 0, 0x1        	MOVF	_ctrlTransferStage, W, B
0010ae   0a01     xorlw	0x1                	XORLW	0x01
0010b0   e10c     bnz	0x10ca               	BNZ	_00402_DS_
                                           ;	.line	669; usb.c	OutDataStage();
0010b2   ec59     call	0x6b2, 0            	CALL	_OutDataStage
0010b4   f003
0010b6   0104     movlb	0x4                	BANKSEL	_ep0Bo
                                           ;	.line	672; usb.c	if(ep0Bo.Stat & DTS)
0010b8   ad00     btfss	0, 0x6, 0x1        	BTFSS	_ep0Bo, 6, B
0010ba   d003     bra	0x10c2               	BRA	_00399_DS_
                                           ;	.line	673; usb.c	ep0Bo.Stat = UOWN | DTSEN;
0010bc   0e88     movlw	0x88               	MOVLW	0x88
                                           ; removed redundant BANKSEL
0010be   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
0010c0   d029     bra	0x1114               	BRA	_00423_DS_
                                           _00399_DS_:
                                           ;	.line	675; usb.c	ep0Bo.Stat = UOWN | DTS | DTSEN;
0010c2   0ec8     movlw	0xc8               	MOVLW	0xc8
0010c4   0104     movlb	0x4                	BANKSEL	_ep0Bo
0010c6   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
0010c8   d025     bra	0x1114               	BRA	_00423_DS_
                                           _00402_DS_:
                                           ;	.line	680; usb.c	WaitForSetupStage();
0010ca   ec85     call	0x150a, 0           	CALL	_WaitForSetupStage
0010cc   f00a
0010ce   d022     bra	0x1114               	BRA	_00423_DS_
                                           _00421_DS_:
                                           ;	.line	683; usb.c	else if(USTAT == 0x04)
0010d0   506c     movf	0x6c, 0, 0          	MOVF	_USTAT, W
0010d2   0a04     xorlw	0x4                	XORLW	0x04
0010d4   e11f     bnz	0x1114               	BNZ	_00423_DS_
                                           ;	.line	686; usb.c	if ((UADDR == 0) && (deviceState == ADDRESS))
0010d6   506e     movf	0x6e, 0, 0          	MOVF	_UADDR, W
0010d8   e10b     bnz	0x10f0               	BNZ	_00410_DS_
0010da   0100     movlb	0                  	BANKSEL	_deviceState
0010dc   51fb     movf	0xfb, 0, 0x1        	MOVF	_deviceState, W, B
0010de   0a04     xorlw	0x4                	XORLW	0x04
0010e0   e107     bnz	0x10f0               	BNZ	_00410_DS_
                                           ;	.line	690; usb.c	UADDR = SetupPacket.wValue0;
0010e2   c582     movff	0x582, 0xf6e       	MOVFF	(_SetupPacket + 2), _UADDR
0010e4   ff6e
                                           ;	.line	692; usb.c	if(UADDR == 0)
0010e6   506e     movf	0x6e, 0, 0          	MOVF	_UADDR, W
0010e8   e103     bnz	0x10f0               	BNZ	_00410_DS_
                                           ;	.line	695; usb.c	deviceState = DEFAULT;
0010ea   0e03     movlw	0x3                	MOVLW	0x03
0010ec   0100     movlb	0                  	BANKSEL	_deviceState
0010ee   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
                                           _00410_DS_:
0010f0   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
                                           ;	.line	698; usb.c	if (ctrlTransferStage == DATA_IN_STAGE)
0010f2   51fd     movf	0xfd, 0, 0x1        	MOVF	_ctrlTransferStage, W, B
0010f4   0a02     xorlw	0x2                	XORLW	0x02
0010f6   e10c     bnz	0x1110               	BNZ	_00416_DS_
                                           ;	.line	701; usb.c	InDataStage();
0010f8   ecc4     call	0x388, 0            	CALL	_InDataStage
0010fa   f001
0010fc   0104     movlb	0x4                	BANKSEL	_ep0Bi
                                           ;	.line	704; usb.c	if(ep0Bi.Stat & DTS)
0010fe   ad04     btfss	0x4, 0x6, 0x1      	BTFSS	_ep0Bi, 6, B
001100   d003     bra	0x1108               	BRA	_00413_DS_
                                           ;	.line	705; usb.c	ep0Bi.Stat = UOWN | DTSEN;
001102   0e88     movlw	0x88               	MOVLW	0x88
                                           ; removed redundant BANKSEL
001104   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
001106   d006     bra	0x1114               	BRA	_00423_DS_
                                           _00413_DS_:
                                           ;	.line	707; usb.c	ep0Bi.Stat = UOWN | DTS | DTSEN;
001108   0ec8     movlw	0xc8               	MOVLW	0xc8
00110a   0104     movlb	0x4                	BANKSEL	_ep0Bi
00110c   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
00110e   d002     bra	0x1114               	BRA	_00423_DS_
                                           _00416_DS_:
                                           ;	.line	712; usb.c	WaitForSetupStage();
001110   ec85     call	0x150a, 0           	CALL	_WaitForSetupStage
001112   f00a
                                           _00423_DS_:
001114   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
001116   f000
001118   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__WaitForSetupStage	code
                                           _WaitForSetupStage:
                                           ;	.line	642; usb.c	void WaitForSetupStage(void)
00150a   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
00150c   ffe5
00150e   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
001510   ffe5
001512   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
                                           ;	.line	644; usb.c	ctrlTransferStage = SETUP_STAGE;
001514   6bfd     clrf	0xfd, 0x1           	CLRF	_ctrlTransferStage, B
                                           ;	.line	645; usb.c	ep0Bo.Cnt = E0SZ;
001516   0e40     movlw	0x40               	MOVLW	0x40
001518   0104     movlb	0x4                	BANKSEL	(_ep0Bo + 1)
00151a   6f01     movwf	0x1, 0x1           	MOVWF	(_ep0Bo + 1), B
                                           ;	.line	646; usb.c	ep0Bo.ADDR = PTR16(&SetupPacket);
00151c   0e80     movlw	0x80               	MOVLW	LOW(_SetupPacket)
00151e   6e00     movwf	0, 0               	MOVWF	r0x00
001520   0e05     movlw	0x5                	MOVLW	HIGH(_SetupPacket)
001522   6e01     movwf	0x1, 0             	MOVWF	r0x01
001524   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ; removed redundant BANKSEL
001526   6f02     movwf	0x2, 0x1           	MOVWF	(_ep0Bo + 2), B
001528   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
00152a   6f03     movwf	0x3, 0x1           	MOVWF	(_ep0Bo + 3), B
                                           ;	.line	647; usb.c	ep0Bo.Stat = UOWN | DTSEN; // Le al SIE, habilita el chequeo de toggle del dato
00152c   0e88     movlw	0x88               	MOVLW	0x88
00152e   0104     movlb	0x4                	BANKSEL	_ep0Bo
001530   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
                                           ; removed redundant BANKSEL
                                           ;	.line	648; usb.c	ep0Bi.Stat = 0x00;         // Da el control al CPU
001532   6b04     clrf	0x4, 0x1            	CLRF	_ep0Bi, B
001534   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
001536   f001
001538   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
00153a   f000
00153c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__SetupStage	code
                                           _SetupStage:
                                           ;	.line	576; usb.c	void SetupStage(void)
000a64   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000a66   ffe5
000a68   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000a6a   ffe5
                                           ;	.line	580; usb.c	ep0Bi.Stat &= ~UOWN;
000a6c   0e7f     movlw	0x7f               	MOVLW	0x7f
000a6e   0104     movlb	0x4                	BANKSEL	_ep0Bi
000a70   1504     andwf	0x4, 0, 0x1        	ANDWF	_ep0Bi, W, B
                                           ; #	MOVWF	r0x00
                                           ; #	MOVF	r0x00, W
000a72   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
                                           ;	.line	581; usb.c	ep0Bo.Stat &= ~UOWN;
000a74   0e7f     movlw	0x7f               	MOVLW	0x7f
                                           ; removed redundant BANKSEL
000a76   1500     andwf	0, 0, 0x1          	ANDWF	_ep0Bo, W, B
                                           ; #	MOVWF	r0x00
                                           ; #	MOVF	r0x00, W
000a78   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
000a7a   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
                                           ;	.line	584; usb.c	ctrlTransferStage = SETUP_STAGE;
000a7c   6bfd     clrf	0xfd, 0x1           	CLRF	_ctrlTransferStage, B
000a7e   0100     movlb	0                  	BANKSEL	_requestHandled
                                           ;	.line	585; usb.c	requestHandled = 0; // La solicitud no ha sido manejada todava
000a80   6bf8     clrf	0xf8, 0x1           	CLRF	_requestHandled, B
000a82   0100     movlb	0                  	BANKSEL	_wCount
                                           ;	.line	586; usb.c	wCount = 0;         // No hay bits transferidos todava
000a84   6bee     clrf	0xee, 0x1           	CLRF	_wCount, B
                                           ; removed redundant BANKSEL
000a86   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
                                           ;	.line	589; usb.c	ProcessStandardRequest();
000a88   eca6     call	0xb4c, 0            	CALL	_ProcessStandardRequest
000a8a   f005
000a8c   0100     movlb	0                  	BANKSEL	_requestHandled
                                           ;	.line	592; usb.c	if (!requestHandled)
000a8e   51f8     movf	0xf8, 0, 0x1        	MOVF	_requestHandled, W, B
000a90   e110     bnz	0xab2                	BNZ	_00379_DS_
                                           ;	.line	596; usb.c	ep0Bo.Cnt = E0SZ;
000a92   0e40     movlw	0x40               	MOVLW	0x40
000a94   0104     movlb	0x4                	BANKSEL	(_ep0Bo + 1)
000a96   6f01     movwf	0x1, 0x1           	MOVWF	(_ep0Bo + 1), B
                                           ;	.line	597; usb.c	ep0Bo.ADDR = PTR16(&SetupPacket);
000a98   0e80     movlw	0x80               	MOVLW	LOW(_SetupPacket)
000a9a   6e00     movwf	0, 0               	MOVWF	r0x00
000a9c   0e05     movlw	0x5                	MOVLW	HIGH(_SetupPacket)
000a9e   6e01     movwf	0x1, 0             	MOVWF	r0x01
000aa0   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ; removed redundant BANKSEL
000aa2   6f02     movwf	0x2, 0x1           	MOVWF	(_ep0Bo + 2), B
000aa4   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
000aa6   6f03     movwf	0x3, 0x1           	MOVWF	(_ep0Bo + 3), B
                                           ; #	MOVLW	0x84
                                           ; #	MOVWF	_ep0Bo, B
                                           ; #	MOVLW	0x84
                                           ;	.line	598; usb.c	ep0Bo.Stat = UOWN | BSTALL;
000aa8   0e84     movlw	0x84               	MOVLW	0x84
000aaa   0104     movlb	0x4                	BANKSEL	_ep0Bo
                                           ;	.line	599; usb.c	ep0Bi.Stat = UOWN | BSTALL;
000aac   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
                                           ; removed redundant BANKSEL
000aae   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
000ab0   d047     bra	0xb40                	BRA	_00380_DS_
                                           _00379_DS_:
000ab2   0105     movlb	0x5                	BANKSEL	_SetupPacket
                                           ;	.line	602; usb.c	else if (SetupPacket.bmRequestType & 0x80)
000ab4   af80     btfss	0x80, 0x7, 0x1     	BTFSS	_SetupPacket, 7, B
000ab6   d02e     bra	0xb14                	BRA	_00376_DS_
000ab8   0100     movlb	0                  	BANKSEL	(_wCount + 1)
                                           ;	.line	605; usb.c	if(SetupPacket.wLength < wCount)
000aba   51ef     movf	0xef, 0, 0x1        	MOVF	(_wCount + 1), W, B
000abc   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 7)
000abe   5d87     subwf	0x87, 0, 0x1       	SUBWF	(_SetupPacket + 7), W, B
000ac0   e104     bnz	0xaca                	BNZ	_00389_DS_
000ac2   0100     movlb	0                  	BANKSEL	_wCount
000ac4   51ee     movf	0xee, 0, 0x1        	MOVF	_wCount, W, B
000ac6   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 6)
000ac8   5d86     subwf	0x86, 0, 0x1       	SUBWF	(_SetupPacket + 6), W, B
                                           _00389_DS_:
000aca   e204     bc	0xad4                 	BC	_00374_DS_
                                           ;	.line	606; usb.c	wCount = SetupPacket.wLength;
000acc   c586     movff	0x586, 0xee        	MOVFF	(_SetupPacket + 6), _wCount
000ace   f0ee
000ad0   c587     movff	0x587, 0xef        	MOVFF	(_SetupPacket + 7), (_wCount + 1)
000ad2   f0ef
                                           _00374_DS_:
                                           ;	.line	608; usb.c	InDataStage();
000ad4   ecc4     call	0x388, 0            	CALL	_InDataStage
000ad6   f001
                                           ;	.line	609; usb.c	ctrlTransferStage = DATA_IN_STAGE;
000ad8   0e02     movlw	0x2                	MOVLW	0x02
000ada   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
000adc   6ffd     movwf	0xfd, 0x1          	MOVWF	_ctrlTransferStage, B
                                           ;	.line	612; usb.c	ep0Bo.Cnt = E0SZ;
000ade   0e40     movlw	0x40               	MOVLW	0x40
000ae0   0104     movlb	0x4                	BANKSEL	(_ep0Bo + 1)
000ae2   6f01     movwf	0x1, 0x1           	MOVWF	(_ep0Bo + 1), B
                                           ;	.line	613; usb.c	ep0Bo.ADDR = PTR16(&SetupPacket);
000ae4   0e80     movlw	0x80               	MOVLW	LOW(_SetupPacket)
000ae6   6e00     movwf	0, 0               	MOVWF	r0x00
000ae8   0e05     movlw	0x5                	MOVLW	HIGH(_SetupPacket)
000aea   6e01     movwf	0x1, 0             	MOVWF	r0x01
000aec   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ; removed redundant BANKSEL
000aee   6f02     movwf	0x2, 0x1           	MOVWF	(_ep0Bo + 2), B
000af0   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
000af2   6f03     movwf	0x3, 0x1           	MOVWF	(_ep0Bo + 3), B
                                           ;	.line	614; usb.c	ep0Bo.Stat = UOWN;
000af4   0e80     movlw	0x80               	MOVLW	0x80
000af6   0104     movlb	0x4                	BANKSEL	_ep0Bo
000af8   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
                                           ;	.line	618; usb.c	ep0Bi.ADDR = PTR16(&controlTransferBuffer);
000afa   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
000afc   6e00     movwf	0, 0               	MOVWF	r0x00
000afe   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
000b00   6e01     movwf	0x1, 0             	MOVWF	r0x01
000b02   5000     movf	0, 0, 0             	MOVF	r0x00, W
000b04   0104     movlb	0x4                	BANKSEL	(_ep0Bi + 2)
000b06   6f06     movwf	0x6, 0x1           	MOVWF	(_ep0Bi + 2), B
000b08   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
000b0a   6f07     movwf	0x7, 0x1           	MOVWF	(_ep0Bi + 3), B
                                           ;	.line	619; usb.c	ep0Bi.Stat = UOWN | DTS | DTSEN; 
000b0c   0ec8     movlw	0xc8               	MOVLW	0xc8
000b0e   0104     movlb	0x4                	BANKSEL	_ep0Bi
000b10   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
000b12   d016     bra	0xb40                	BRA	_00380_DS_
                                           _00376_DS_:
                                           ;	.line	624; usb.c	ctrlTransferStage = DATA_OUT_STAGE;
000b14   0e01     movlw	0x1                	MOVLW	0x01
000b16   0100     movlb	0                  	BANKSEL	_ctrlTransferStage
000b18   6ffd     movwf	0xfd, 0x1          	MOVWF	_ctrlTransferStage, B
000b1a   0104     movlb	0x4                	BANKSEL	(_ep0Bi + 1)
                                           ;	.line	627; usb.c	ep0Bi.Cnt = 0;
000b1c   6b05     clrf	0x5, 0x1            	CLRF	(_ep0Bi + 1), B
                                           ;	.line	628; usb.c	ep0Bi.Stat = UOWN | DTS | DTSEN;
000b1e   0ec8     movlw	0xc8               	MOVLW	0xc8
000b20   0104     movlb	0x4                	BANKSEL	_ep0Bi
000b22   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
                                           ;	.line	632; usb.c	ep0Bo.Cnt = E0SZ;
000b24   0e40     movlw	0x40               	MOVLW	0x40
000b26   0104     movlb	0x4                	BANKSEL	(_ep0Bo + 1)
000b28   6f01     movwf	0x1, 0x1           	MOVWF	(_ep0Bo + 1), B
                                           ;	.line	633; usb.c	ep0Bo.ADDR = PTR16(&controlTransferBuffer);
000b2a   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
000b2c   6e00     movwf	0, 0               	MOVWF	r0x00
000b2e   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
000b30   6e01     movwf	0x1, 0             	MOVWF	r0x01
000b32   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ; removed redundant BANKSEL
000b34   6f02     movwf	0x2, 0x1           	MOVWF	(_ep0Bo + 2), B
000b36   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
000b38   6f03     movwf	0x3, 0x1           	MOVWF	(_ep0Bo + 3), B
                                           ;	.line	634; usb.c	ep0Bo.Stat = UOWN | DTS | DTSEN;
000b3a   0ec8     movlw	0xc8               	MOVLW	0xc8
000b3c   0104     movlb	0x4                	BANKSEL	_ep0Bo
000b3e   6f00     movwf	0, 0x1             	MOVWF	_ep0Bo, B
                                           _00380_DS_:
                                           ;	.line	637; usb.c	UCONbits.PKTDIS = 0;
000b40   986d     bcf	0x6d, 0x4, 0         	BCF	_UCONbits, 4
000b42   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000b44   f001
000b46   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000b48   f000
000b4a   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__OutDataStage	code
                                           _OutDataStage:
                                           ;	.line	557; usb.c	void OutDataStage(void)
0006b2   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0006b4   ffe5
0006b6   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0006b8   ffe5
0006ba   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
0006bc   ffe5
0006be   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
0006c0   ffe5
0006c2   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
0006c4   ffe5
0006c6   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
0006c8   ffe5
0006ca   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
0006cc   ffe5
0006ce   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
0006d0   ffe5
0006d2   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
0006d4   ffe5
0006d6   c009     movff	0x9, 0xfe5         	MOVFF	r0x09, POSTDEC1
0006d8   ffe5
                                           ;	.line	561; usb.c	bufferSize = ((0x03 & ep0Bo.Stat) << 8) | ep0Bo.Cnt;
0006da   0e03     movlw	0x3                	MOVLW	0x03
0006dc   0104     movlb	0x4                	BANKSEL	_ep0Bo
0006de   1500     andwf	0, 0, 0x1          	ANDWF	_ep0Bo, W, B
0006e0   6a01     clrf	0x1, 0              	CLRF	r0x01
0006e2   6e03     movwf	0x3, 0             	MOVWF	r0x03
0006e4   6a02     clrf	0x2, 0              	CLRF	r0x02
0006e6   c401     movff	0x401, 0           	MOVFF	(_ep0Bo + 1), r0x00
0006e8   f000
0006ea   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
0006ec   1200     iorwf	0, 0x1, 0          	IORWF	r0x00, F
0006ee   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
0006f0   1201     iorwf	0x1, 0x1, 0        	IORWF	r0x01, F
                                           ;	.line	564; usb.c	wCount = wCount + bufferSize;
0006f2   5000     movf	0, 0, 0             	MOVF	r0x00, W
0006f4   0100     movlb	0                  	BANKSEL	_wCount
0006f6   27ee     addwf	0xee, 0x1, 0x1     	ADDWF	_wCount, F, B
0006f8   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
0006fa   23ef     addwfc	0xef, 0x1, 0x1    	ADDWFC	(_wCount + 1), F, B
                                           ;	.line	566; usb.c	outPtr = (byte*)&controlTransferBuffer;
0006fc   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
0006fe   0100     movlb	0                  	BANKSEL	(_outPtr + 1)
000700   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000702   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
                                           ; removed redundant BANKSEL
000704   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000706   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
000708   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	568; usb.c	for (i=0;i<bufferSize;i++)
00070a   6a03     clrf	0x3, 0              	CLRF	r0x03
                                           _00358_DS_:
00070c   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
00070e   5c03     subwf	0x3, 0, 0          	SUBWF	r0x03, W
000710   e102     bnz	0x716                	BNZ	_00368_DS_
000712   5000     movf	0, 0, 0             	MOVF	r0x00, W
000714   5c02     subwf	0x2, 0, 0          	SUBWF	r0x02, W
                                           _00368_DS_:
000716   e22f     bc	0x776                 	BC	_00362_DS_
                                           ;	.line	569; usb.c	*inPtr++ = *outPtr++; //Copia los contenidos de los buffer bit a bit
000718   c0eb     movff	0xeb, 0x4          	MOVFF	_inPtr, r0x04
00071a   f004
00071c   c0ec     movff	0xec, 0x5          	MOVFF	(_inPtr + 1), r0x05
00071e   f005
000720   c0ed     movff	0xed, 0x6          	MOVFF	(_inPtr + 2), r0x06
000722   f006
000724   c0e8     movff	0xe8, 0x7          	MOVFF	_outPtr, r0x07
000726   f007
000728   c0e9     movff	0xe9, 0x8          	MOVFF	(_outPtr + 1), r0x08
00072a   f008
00072c   c0ea     movff	0xea, 0x9          	MOVFF	(_outPtr + 2), r0x09
00072e   f009
000730   c007     movff	0x7, 0xfe9         	MOVFF	r0x07, FSR0L
000732   ffe9
000734   c008     movff	0x8, 0xff3         	MOVFF	r0x08, PRODL
000736   fff3
000738   5009     movf	0x9, 0, 0           	MOVF	r0x09, W
00073a   ecc9     call	0x1592, 0           	CALL	__gptrget1
00073c   f00a
00073e   6e07     movwf	0x7, 0             	MOVWF	r0x07
000740   0100     movlb	0                  	BANKSEL	_outPtr
000742   2be8     incf	0xe8, 0x1, 0x1      	INCF	_outPtr, F, B
000744   e301     bnc	0x748                	BNC	_10498_DS_
                                           ; removed redundant BANKSEL
000746   2be9     incf	0xe9, 0x1, 0x1      	INCF	(_outPtr + 1), F, B
                                           _10498_DS_:
000748   e302     bnc	0x74e                	BNC	_20499_DS_
00074a   0100     movlb	0                  	BANKSEL	(_outPtr + 2)
00074c   2bea     incf	0xea, 0x1, 0x1      	INCF	(_outPtr + 2), F, B
                                           _20499_DS_:
00074e   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
000750   ffe5
000752   c004     movff	0x4, 0xfe9         	MOVFF	r0x04, FSR0L
000754   ffe9
000756   c005     movff	0x5, 0xff3         	MOVFF	r0x05, PRODL
000758   fff3
00075a   5006     movf	0x6, 0, 0           	MOVF	r0x06, W
00075c   ec0f     call	0x161e, 0           	CALL	__gptrput1
00075e   f00b
000760   0100     movlb	0                  	BANKSEL	_inPtr
000762   2beb     incf	0xeb, 0x1, 0x1      	INCF	_inPtr, F, B
000764   e301     bnc	0x768                	BNC	_30500_DS_
                                           ; removed redundant BANKSEL
000766   2bec     incf	0xec, 0x1, 0x1      	INCF	(_inPtr + 1), F, B
                                           _30500_DS_:
000768   e302     bnc	0x76e                	BNC	_40501_DS_
00076a   0100     movlb	0                  	BANKSEL	(_inPtr + 2)
00076c   2bed     incf	0xed, 0x1, 0x1      	INCF	(_inPtr + 2), F, B
                                           _40501_DS_:
                                           ;	.line	568; usb.c	for (i=0;i<bufferSize;i++)
00076e   2a02     incf	0x2, 0x1, 0         	INCF	r0x02, F
000770   b0d8     btfsc	0xd8, 0, 0         	BTFSC	STATUS, 0
000772   2a03     incf	0x3, 0x1, 0         	INCF	r0x03, F
000774   d7cb     bra	0x70c                	BRA	_00358_DS_
                                           _00362_DS_:
000776   cfe4     movff	0xfe4, 0x9         	MOVFF	PREINC1, r0x09
000778   f009
00077a   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
00077c   f008
00077e   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
000780   f007
000782   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
000784   f006
000786   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
000788   f005
00078a   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
00078c   f004
00078e   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000790   f003
000792   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000794   f002
000796   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000798   f001
00079a   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
00079c   f000
00079e   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__InDataStage	code
                                           _InDataStage:
                                           ;	.line	526; usb.c	void InDataStage(void)
000388   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
00038a   ffe5
00038c   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
00038e   ffe5
000390   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000392   ffe5
000394   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000396   ffe5
000398   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
00039a   ffe5
00039c   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
00039e   ffe5
0003a0   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
0003a2   ffe5
0003a4   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
0003a6   ffe5
0003a8   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
0003aa   ffe5
                                           ;	.line	533; usb.c	if(wCount < E0SZ)
0003ac   0e00     movlw	0                  	MOVLW	0x00
0003ae   0100     movlb	0                  	BANKSEL	(_wCount + 1)
0003b0   5def     subwf	0xef, 0, 0x1       	SUBWF	(_wCount + 1), W, B
0003b2   e102     bnz	0x3b8                	BNZ	_00348_DS_
0003b4   0e40     movlw	0x40               	MOVLW	0x40
                                           ; removed redundant BANKSEL
0003b6   5dee     subwf	0xee, 0, 0x1       	SUBWF	_wCount, W, B
                                           _00348_DS_:
0003b8   e205     bc	0x3c4                 	BC	_00336_DS_
                                           ;	.line	534; usb.c	bufferSize = wCount;
0003ba   c0ee     movff	0xee, 0            	MOVFF	_wCount, r0x00
0003bc   f000
0003be   c0ef     movff	0xef, 0x1          	MOVFF	(_wCount + 1), r0x01
0003c0   f001
0003c2   d003     bra	0x3ca                	BRA	_00337_DS_
                                           _00336_DS_:
                                           ;	.line	536; usb.c	bufferSize = E0SZ;
0003c4   0e40     movlw	0x40               	MOVLW	0x40
0003c6   6e00     movwf	0, 0               	MOVWF	r0x00
0003c8   6a01     clrf	0x1, 0              	CLRF	r0x01
                                           _00337_DS_:
                                           ;	.line	539; usb.c	ep0Bi.Stat &= ~(BC8 | BC9); // Borra BC8 y BC9
0003ca   0efc     movlw	0xfc               	MOVLW	0xfc
0003cc   0104     movlb	0x4                	BANKSEL	_ep0Bi
0003ce   1504     andwf	0x4, 0, 0x1        	ANDWF	_ep0Bi, W, B
                                           ; #	MOVWF	r0x02
                                           ; #	MOVF	r0x02, W
0003d0   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
                                           ;	.line	540; usb.c	ep0Bi.Stat |= (byte)((bufferSize & 0x0300) >> 8);
0003d2   0e03     movlw	0x3                	MOVLW	0x03
0003d4   1401     andwf	0x1, 0, 0          	ANDWF	r0x01, W
                                           ; #	MOVWF	r0x03
                                           ; #	MOVF	r0x03, W
0003d6   6e02     movwf	0x2, 0             	MOVWF	r0x02
                                           ; removed redundant BANKSEL
0003d8   5104     movf	0x4, 0, 0x1         	MOVF	_ep0Bi, W, B
0003da   1202     iorwf	0x2, 0x1, 0        	IORWF	r0x02, F
0003dc   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
                                           ; removed redundant BANKSEL
0003de   6f04     movwf	0x4, 0x1           	MOVWF	_ep0Bi, B
                                           ; #	MOVF	r0x00, W
                                           ; #	MOVWF	r0x02
                                           ; #	MOVF	r0x02, W
                                           ;	.line	541; usb.c	ep0Bi.Cnt = (byte)(bufferSize & 0xFF);
0003e0   5000     movf	0, 0, 0             	MOVF	r0x00, W
0003e2   6e02     movwf	0x2, 0             	MOVWF	r0x02
0003e4   0104     movlb	0x4                	BANKSEL	(_ep0Bi + 1)
0003e6   6f05     movwf	0x5, 0x1           	MOVWF	(_ep0Bi + 1), B
                                           ;	.line	542; usb.c	ep0Bi.ADDR = PTR16(&controlTransferBuffer);
0003e8   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
0003ea   6e02     movwf	0x2, 0             	MOVWF	r0x02
0003ec   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
0003ee   6e03     movwf	0x3, 0             	MOVWF	r0x03
0003f0   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
                                           ; removed redundant BANKSEL
0003f2   6f06     movwf	0x6, 0x1           	MOVWF	(_ep0Bi + 2), B
0003f4   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
                                           ; removed redundant BANKSEL
0003f6   6f07     movwf	0x7, 0x1           	MOVWF	(_ep0Bi + 3), B
                                           ;	.line	547; usb.c	wCount = wCount - bufferSize;
0003f8   5000     movf	0, 0, 0             	MOVF	r0x00, W
0003fa   0100     movlb	0                  	BANKSEL	_wCount
0003fc   5fee     subwf	0xee, 0x1, 0x1     	SUBWF	_wCount, F, B
0003fe   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
000400   5bef     subwfb	0xef, 0x1, 0x1    	SUBWFB	(_wCount + 1), F, B
                                           ;	.line	550; usb.c	inPtr = (byte *)&controlTransferBuffer;
000402   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
000404   0100     movlb	0                  	BANKSEL	(_inPtr + 1)
000406   6fec     movwf	0xec, 0x1          	MOVWF	(_inPtr + 1), B
000408   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
                                           ; removed redundant BANKSEL
00040a   6feb     movwf	0xeb, 0x1          	MOVWF	_inPtr, B
00040c   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
00040e   6fed     movwf	0xed, 0x1          	MOVWF	(_inPtr + 2), B
                                           ;	.line	552; usb.c	for (i=0;i<bufferSize;i++)
000410   6a02     clrf	0x2, 0              	CLRF	r0x02
                                           _00338_DS_:
000412   c002     movff	0x2, 0x3           	MOVFF	r0x02, r0x03
000414   f003
000416   6a04     clrf	0x4, 0              	CLRF	r0x04
000418   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
00041a   5c04     subwf	0x4, 0, 0          	SUBWF	r0x04, W
00041c   e102     bnz	0x422                	BNZ	_00353_DS_
00041e   5000     movf	0, 0, 0             	MOVF	r0x00, W
000420   5c03     subwf	0x3, 0, 0          	SUBWF	r0x03, W
                                           _00353_DS_:
000422   e22d     bc	0x47e                 	BC	_00342_DS_
                                           ;	.line	553; usb.c	*inPtr++ = *outPtr++; //Copia los contenidos de los buffer bit a bit
000424   c0eb     movff	0xeb, 0x3          	MOVFF	_inPtr, r0x03
000426   f003
000428   c0ec     movff	0xec, 0x4          	MOVFF	(_inPtr + 1), r0x04
00042a   f004
00042c   c0ed     movff	0xed, 0x5          	MOVFF	(_inPtr + 2), r0x05
00042e   f005
000430   c0e8     movff	0xe8, 0x6          	MOVFF	_outPtr, r0x06
000432   f006
000434   c0e9     movff	0xe9, 0x7          	MOVFF	(_outPtr + 1), r0x07
000436   f007
000438   c0ea     movff	0xea, 0x8          	MOVFF	(_outPtr + 2), r0x08
00043a   f008
00043c   c006     movff	0x6, 0xfe9         	MOVFF	r0x06, FSR0L
00043e   ffe9
000440   c007     movff	0x7, 0xff3         	MOVFF	r0x07, PRODL
000442   fff3
000444   5008     movf	0x8, 0, 0           	MOVF	r0x08, W
000446   ecc9     call	0x1592, 0           	CALL	__gptrget1
000448   f00a
00044a   6e06     movwf	0x6, 0             	MOVWF	r0x06
00044c   0100     movlb	0                  	BANKSEL	_outPtr
00044e   2be8     incf	0xe8, 0x1, 0x1      	INCF	_outPtr, F, B
000450   e301     bnc	0x454                	BNC	_50502_DS_
                                           ; removed redundant BANKSEL
000452   2be9     incf	0xe9, 0x1, 0x1      	INCF	(_outPtr + 1), F, B
                                           _50502_DS_:
000454   e302     bnc	0x45a                	BNC	_60503_DS_
000456   0100     movlb	0                  	BANKSEL	(_outPtr + 2)
000458   2bea     incf	0xea, 0x1, 0x1      	INCF	(_outPtr + 2), F, B
                                           _60503_DS_:
00045a   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
00045c   ffe5
00045e   c003     movff	0x3, 0xfe9         	MOVFF	r0x03, FSR0L
000460   ffe9
000462   c004     movff	0x4, 0xff3         	MOVFF	r0x04, PRODL
000464   fff3
000466   5005     movf	0x5, 0, 0           	MOVF	r0x05, W
000468   ec0f     call	0x161e, 0           	CALL	__gptrput1
00046a   f00b
00046c   0100     movlb	0                  	BANKSEL	_inPtr
00046e   2beb     incf	0xeb, 0x1, 0x1      	INCF	_inPtr, F, B
000470   e301     bnc	0x474                	BNC	_70504_DS_
                                           ; removed redundant BANKSEL
000472   2bec     incf	0xec, 0x1, 0x1      	INCF	(_inPtr + 1), F, B
                                           _70504_DS_:
000474   e302     bnc	0x47a                	BNC	_80505_DS_
000476   0100     movlb	0                  	BANKSEL	(_inPtr + 2)
000478   2bed     incf	0xed, 0x1, 0x1      	INCF	(_inPtr + 2), F, B
                                           _80505_DS_:
                                           ;	.line	552; usb.c	for (i=0;i<bufferSize;i++)
00047a   2a02     incf	0x2, 0x1, 0         	INCF	r0x02, F
00047c   d7ca     bra	0x412                	BRA	_00338_DS_
                                           _00342_DS_:
00047e   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
000480   f008
000482   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
000484   f007
000486   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
000488   f006
00048a   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
00048c   f005
00048e   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000490   f004
000492   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000494   f003
000496   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000498   f002
00049a   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
00049c   f001
00049e   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0004a0   f000
0004a2   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__ProcessStandardRequest	code
                                           _ProcessStandardRequest:
                                           ;	.line	442; usb.c	void ProcessStandardRequest(void)
000b4c   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000b4e   ffe5
000b50   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000b52   ffe5
                                           ;	.line	444; usb.c	byte request = SetupPacket.bRequest; 
000b54   c581     movff	0x581, 0           	MOVFF	(_SetupPacket + 1), r0x00
000b56   f000
                                           ;	.line	446; usb.c	if((SetupPacket.bmRequestType & 0x60) != 0x00)
000b58   0e60     movlw	0x60               	MOVLW	0x60
000b5a   0105     movlb	0x5                	BANKSEL	_SetupPacket
000b5c   1580     andwf	0x80, 0, 0x1       	ANDWF	_SetupPacket, W, B
000b5e   6e01     movwf	0x1, 0             	MOVWF	r0x01
000b60   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000b62   e001     bz	0xb66                 	BZ	_00272_DS_
                                           ;	.line	450; usb.c	return;
000b64   d061     bra	0xc28                	BRA	_00300_DS_
                                           _00272_DS_:
                                           ;	.line	453; usb.c	if (request == SET_ADDRESS)
000b66   5000     movf	0, 0, 0             	MOVF	r0x00, W
000b68   0a05     xorlw	0x5                	XORLW	0x05
000b6a   e109     bnz	0xb7e                	BNZ	_00298_DS_
                                           ;	.line	459; usb.c	requestHandled = 1;
000b6c   0e01     movlw	0x1                	MOVLW	0x01
000b6e   0100     movlb	0                  	BANKSEL	_requestHandled
000b70   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	460; usb.c	deviceState = ADDRESS;
000b72   0e04     movlw	0x4                	MOVLW	0x04
000b74   0100     movlb	0                  	BANKSEL	_deviceState
000b76   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
                                           ;	.line	462; usb.c	deviceAddress = SetupPacket.wValue0;
000b78   c582     movff	0x582, 0xf6        	MOVFF	(_SetupPacket + 2), _deviceAddress
000b7a   f0f6
000b7c   d055     bra	0xc28                	BRA	_00300_DS_
                                           _00298_DS_:
                                           ;	.line	464; usb.c	else if (request == GET_DESCRIPTOR)
000b7e   5000     movf	0, 0, 0             	MOVF	r0x00, W
000b80   0a06     xorlw	0x6                	XORLW	0x06
000b82   e103     bnz	0xb8a                	BNZ	_00295_DS_
                                           ;	.line	466; usb.c	GetDescriptor();
000b84   ecd0     call	0x7a0, 0            	CALL	_GetDescriptor
000b86   f003
000b88   d04f     bra	0xc28                	BRA	_00300_DS_
                                           _00295_DS_:
                                           ;	.line	469; usb.c	else if (request == SET_CONFIGURATION)
000b8a   5000     movf	0, 0, 0             	MOVF	r0x00, W
000b8c   0a09     xorlw	0x9                	XORLW	0x09
000b8e   e112     bnz	0xbb4                	BNZ	_00292_DS_
                                           ;	.line	471; usb.c	requestHandled = 1;
000b90   0e01     movlw	0x1                	MOVLW	0x01
000b92   0100     movlb	0                  	BANKSEL	_requestHandled
000b94   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	472; usb.c	currentConfiguration = SetupPacket.wValue0;
000b96   c582     movff	0x582, 0xfc        	MOVFF	(_SetupPacket + 2), _currentConfiguration
000b98   f0fc
000b9a   0100     movlb	0                  	BANKSEL	_currentConfiguration
                                           ;	.line	475; usb.c	if (currentConfiguration == 0)
000b9c   51fc     movf	0xfc, 0, 0x1        	MOVF	_currentConfiguration, W, B
000b9e   e104     bnz	0xba8                	BNZ	_00274_DS_
                                           ;	.line	478; usb.c	deviceState = ADDRESS;
000ba0   0e04     movlw	0x4                	MOVLW	0x04
000ba2   0100     movlb	0                  	BANKSEL	_deviceState
000ba4   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
000ba6   d040     bra	0xc28                	BRA	_00300_DS_
                                           _00274_DS_:
                                           ;	.line	482; usb.c	deviceState = CONFIGURED;
000ba8   0e05     movlw	0x5                	MOVLW	0x05
000baa   0100     movlb	0                  	BANKSEL	_deviceState
000bac   6ffb     movwf	0xfb, 0x1          	MOVWF	_deviceState, B
                                           ;	.line	484; usb.c	InitEndpoint();
000bae   ecf0     call	0x13e0, 0           	CALL	_InitEndpoint
000bb0   f009
000bb2   d03a     bra	0xc28                	BRA	_00300_DS_
                                           _00292_DS_:
                                           ;	.line	490; usb.c	else if (request == GET_CONFIGURATION)
000bb4   5000     movf	0, 0, 0             	MOVF	r0x00, W
000bb6   0a08     xorlw	0x8                	XORLW	0x08
000bb8   e10f     bnz	0xbd8                	BNZ	_00289_DS_
                                           ;	.line	492; usb.c	requestHandled = 1;
000bba   0e01     movlw	0x1                	MOVLW	0x01
000bbc   0100     movlb	0                  	BANKSEL	_requestHandled
000bbe   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	493; usb.c	outPtr = (byte*)&currentConfiguration;
000bc0   0e00     movlw	0                  	MOVLW	HIGH(_currentConfiguration)
000bc2   0100     movlb	0                  	BANKSEL	(_outPtr + 1)
000bc4   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000bc6   0efc     movlw	0xfc               	MOVLW	LOW(_currentConfiguration)
                                           ; removed redundant BANKSEL
000bc8   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000bca   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
000bcc   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	494; usb.c	wCount = 1;
000bce   0e01     movlw	0x1                	MOVLW	0x01
000bd0   0100     movlb	0                  	BANKSEL	_wCount
000bd2   6fee     movwf	0xee, 0x1          	MOVWF	_wCount, B
                                           ; removed redundant BANKSEL
000bd4   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
000bd6   d028     bra	0xc28                	BRA	_00300_DS_
                                           _00289_DS_:
                                           ;	.line	496; usb.c	else if (request == GET_STATUS)
000bd8   5000     movf	0, 0, 0             	MOVF	r0x00, W
000bda   e103     bnz	0xbe2                	BNZ	_00286_DS_
                                           ;	.line	498; usb.c	GetStatus();
000bdc   ece0     call	0x5c0, 0            	CALL	_GetStatus
000bde   f002
000be0   d023     bra	0xc28                	BRA	_00300_DS_
                                           _00286_DS_:
                                           ;	.line	500; usb.c	else if ((request == CLEAR_FEATURE) ||
000be2   5000     movf	0, 0, 0             	MOVF	r0x00, W
000be4   0a01     xorlw	0x1                	XORLW	0x01
000be6   e003     bz	0xbee                 	BZ	_00281_DS_
                                           ;	.line	501; usb.c	(request == SET_FEATURE))
000be8   5000     movf	0, 0, 0             	MOVF	r0x00, W
000bea   0a03     xorlw	0x3                	XORLW	0x03
000bec   e103     bnz	0xbf4                	BNZ	_00282_DS_
                                           _00281_DS_:
                                           ;	.line	503; usb.c	SetFeature();
000bee   ec52     call	0x4a4, 0            	CALL	_SetFeature
000bf0   f002
000bf2   d01a     bra	0xc28                	BRA	_00300_DS_
                                           _00282_DS_:
                                           ;	.line	505; usb.c	else if (request == GET_INTERFACE)
000bf4   5000     movf	0, 0, 0             	MOVF	r0x00, W
000bf6   0a0a     xorlw	0xa                	XORLW	0x0a
000bf8   e111     bnz	0xc1c                	BNZ	_00279_DS_
                                           ;	.line	510; usb.c	requestHandled = 1;
000bfa   0e01     movlw	0x1                	MOVLW	0x01
000bfc   0100     movlb	0                  	BANKSEL	_requestHandled
000bfe   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
000c00   0105     movlb	0x5                	BANKSEL	_controlTransferBuffer
                                           ;	.line	511; usb.c	controlTransferBuffer[0] = 0;
000c02   6bc0     clrf	0xc0, 0x1           	CLRF	_controlTransferBuffer, B
                                           ;	.line	512; usb.c	outPtr = &controlTransferBuffer;
000c04   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
000c06   0100     movlb	0                  	BANKSEL	(_outPtr + 1)
000c08   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000c0a   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
                                           ; removed redundant BANKSEL
000c0c   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000c0e   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
000c10   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	513; usb.c	wCount = 1;
000c12   0e01     movlw	0x1                	MOVLW	0x01
000c14   0100     movlb	0                  	BANKSEL	_wCount
000c16   6fee     movwf	0xee, 0x1          	MOVWF	_wCount, B
                                           ; removed redundant BANKSEL
000c18   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
000c1a   d006     bra	0xc28                	BRA	_00300_DS_
                                           _00279_DS_:
                                           ;	.line	515; usb.c	else if (request == SET_INTERFACE)
000c1c   5000     movf	0, 0, 0             	MOVF	r0x00, W
000c1e   0a0b     xorlw	0xb                	XORLW	0x0b
000c20   e103     bnz	0xc28                	BNZ	_00300_DS_
                                           ;	.line	518; usb.c	requestHandled = 1;
000c22   0e01     movlw	0x1                	MOVLW	0x01
000c24   0100     movlb	0                  	BANKSEL	_requestHandled
000c26   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           _00300_DS_:
000c28   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000c2a   f001
000c2c   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000c2e   f000
000c30   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__SetFeature	code
                                           _SetFeature:
                                           ;	.line	378; usb.c	static void SetFeature(void)
0004a4   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0004a6   ffe5
0004a8   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0004aa   ffe5
0004ac   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
0004ae   ffe5
0004b0   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
0004b2   ffe5
                                           ;	.line	380; usb.c	byte recipient = SetupPacket.bmRequestType & 0x1F; // D4..0 es Recipient (Dev, Interf o Endp)
0004b4   0e1f     movlw	0x1f               	MOVLW	0x1f
0004b6   0105     movlb	0x5                	BANKSEL	_SetupPacket
0004b8   1580     andwf	0x80, 0, 0x1       	ANDWF	_SetupPacket, W, B
0004ba   6e00     movwf	0, 0               	MOVWF	r0x00
                                           ;	.line	382; usb.c	byte feature = SetupPacket.wValue0;
0004bc   c582     movff	0x582, 0x1         	MOVFF	(_SetupPacket + 2), r0x01
0004be   f001
                                           ;	.line	385; usb.c	if (recipient == 0x00) // El desriptor solicitado es el dispositivo
0004c0   5000     movf	0, 0, 0             	MOVF	r0x00, W
0004c2   e112     bnz	0x4e8                	BNZ	_00239_DS_
                                           ;	.line	388; usb.c	if (feature == DEVICE_REMOTE_WAKEUP)
0004c4   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
0004c6   0a01     xorlw	0x1                	XORLW	0x01
0004c8   e001     bz	0x4cc                 	BZ	_00254_DS_
0004ca   d071     bra	0x5ae                	BRA	_00241_DS_
                                           _00254_DS_:
                                           ;	.line	390; usb.c	requestHandled = 1;
0004cc   0e01     movlw	0x1                	MOVLW	0x01
0004ce   0100     movlb	0                  	BANKSEL	_requestHandled
0004d0   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
0004d2   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 1)
                                           ;	.line	392; usb.c	if (SetupPacket.bRequest == SET_FEATURE)
0004d4   5181     movf	0x81, 0, 0x1        	MOVF	(_SetupPacket + 1), W, B
0004d6   0a03     xorlw	0x3                	XORLW	0x03
0004d8   e104     bnz	0x4e2                	BNZ	_00221_DS_
                                           ;	.line	393; usb.c	remoteWakeup = 1;
0004da   0e01     movlw	0x1                	MOVLW	0x01
0004dc   0100     movlb	0                  	BANKSEL	_remoteWakeup
0004de   6ffa     movwf	0xfa, 0x1          	MOVWF	_remoteWakeup, B
0004e0   d066     bra	0x5ae                	BRA	_00241_DS_
                                           _00221_DS_:
0004e2   0100     movlb	0                  	BANKSEL	_remoteWakeup
                                           ;	.line	395; usb.c	remoteWakeup = 0;
0004e4   6bfa     clrf	0xfa, 0x1           	CLRF	_remoteWakeup, B
0004e6   d063     bra	0x5ae                	BRA	_00241_DS_
                                           _00239_DS_:
                                           ;	.line	405; usb.c	else if (recipient == 0x02) // El desriptor solicitado es el endpoint
0004e8   5000     movf	0, 0, 0             	MOVF	r0x00, W
0004ea   0a02     xorlw	0x2                	XORLW	0x02
0004ec   e001     bz	0x4f0                 	BZ	_00258_DS_
0004ee   d05f     bra	0x5ae                	BRA	_00241_DS_
                                           _00258_DS_:
                                           ;	.line	409; usb.c	byte endpointNum = SetupPacket.wIndex0 & 0x0F;
0004f0   0e0f     movlw	0xf                	MOVLW	0x0f
0004f2   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 4)
0004f4   1584     andwf	0x84, 0, 0x1       	ANDWF	(_SetupPacket + 4), W, B
0004f6   6e00     movwf	0, 0               	MOVWF	r0x00
                                           ;	.line	410; usb.c	byte endpointDir = SetupPacket.wIndex0 & 0x80;
0004f8   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
0004fa   1584     andwf	0x84, 0, 0x1       	ANDWF	(_SetupPacket + 4), W, B
0004fc   6e02     movwf	0x2, 0             	MOVWF	r0x02
                                           ;	.line	412; usb.c	if ((feature == ENDPOINT_HALT) && (endpointNum != 0))
0004fe   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000500   a4d8     btfss	0xd8, 0x2, 0       	BTFSS	STATUS, 2
000502   d055     bra	0x5ae                	BRA	_00241_DS_
000504   5000     movf	0, 0, 0             	MOVF	r0x00, W
000506   e101     bnz	0x50a                	BNZ	_00262_DS_
000508   d052     bra	0x5ae                	BRA	_00241_DS_
                                           _00262_DS_:
                                           ;	.line	414; usb.c	requestHandled = 1;
00050a   0e01     movlw	0x1                	MOVLW	0x01
00050c   0100     movlb	0                  	BANKSEL	_requestHandled
00050e   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ; ;multiply lit val:0x08 by variable r0x00 and store in r0x00
                                           ; ;Unrolled 8 X 8 multiplication
                                           ; ;FIXME: the function does not support result==WREG
                                           ;	.line	422; usb.c	inPtr = (byte *)&ep0Bo + (endpointNum * 8); 
000510   5000     movf	0, 0, 0             	MOVF	r0x00, W
000512   0d08     mullw	0x8                	MULLW	0x08
000514   cff3     movff	0xff3, 0           	MOVFF	PRODL, r0x00
000516   f000
000518   cff4     movff	0xff4, 0x1         	MOVFF	PRODH, r0x01
00051a   f001
00051c   5000     movf	0, 0, 0             	MOVF	r0x00, W
00051e   0100     movlb	0                  	BANKSEL	_inPtr
000520   6feb     movwf	0xeb, 0x1          	MOVWF	_inPtr, B
000522   0e04     movlw	0x4                	MOVLW	0x04
000524   2401     addwf	0x1, 0, 0          	ADDWF	r0x01, W
                                           ; removed redundant BANKSEL
000526   6fec     movwf	0xec, 0x1          	MOVWF	(_inPtr + 1), B
000528   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
00052a   6bed     clrf	0xed, 0x1           	CLRF	(_inPtr + 2), B
00052c   ae01     btfss	0x1, 0x7, 0        	BTFSS	r0x01, 7
00052e   d001     bra	0x532                	BRA	_90506_DS_
                                           ; removed redundant BANKSEL
000530   69ed     setf	0xed, 0x1           	SETF	(_inPtr + 2), B
                                           _90506_DS_:
000532   0100     movlb	0                  	BANKSEL	(_inPtr + 2)
000534   23ed     addwfc	0xed, 0x1, 0x1    	ADDWFC	(_inPtr + 2), F, B
                                           ;	.line	423; usb.c	if (endpointDir)
000536   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000538   e005     bz	0x544                 	BZ	_00226_DS_
                                           ;	.line	424; usb.c	inPtr += 4;
00053a   0e04     movlw	0x4                	MOVLW	0x04
                                           ; removed redundant BANKSEL
00053c   27eb     addwf	0xeb, 0x1, 0x1     	ADDWF	_inPtr, F, B
00053e   0e00     movlw	0                  	MOVLW	0x00
                                           ; removed redundant BANKSEL
000540   23ec     addwfc	0xec, 0x1, 0x1    	ADDWFC	(_inPtr + 1), F, B
                                           ; removed redundant BANKSEL
000542   23ed     addwfc	0xed, 0x1, 0x1    	ADDWFC	(_inPtr + 2), F, B
                                           _00226_DS_:
000544   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 1)
                                           ;	.line	426; usb.c	if(SetupPacket.bRequest == SET_FEATURE)
000546   5181     movf	0x81, 0, 0x1        	MOVF	(_SetupPacket + 1), W, B
000548   0a03     xorlw	0x3                	XORLW	0x03
00054a   e110     bnz	0x56c                	BNZ	_00231_DS_
                                           ;	.line	427; usb.c	*inPtr = 0x84;
00054c   c0eb     movff	0xeb, 0            	MOVFF	_inPtr, r0x00
00054e   f000
000550   c0ec     movff	0xec, 0x1          	MOVFF	(_inPtr + 1), r0x01
000552   f001
000554   c0ed     movff	0xed, 0x3          	MOVFF	(_inPtr + 2), r0x03
000556   f003
000558   0e84     movlw	0x84               	MOVLW	0x84
00055a   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
00055c   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
00055e   ffe9
000560   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
000562   fff3
000564   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
000566   ec0f     call	0x161e, 0           	CALL	__gptrput1
000568   f00b
00056a   d021     bra	0x5ae                	BRA	_00241_DS_
                                           _00231_DS_:
                                           ;	.line	431; usb.c	if(endpointDir == 1)
00056c   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
00056e   0a01     xorlw	0x1                	XORLW	0x01
000570   e10f     bnz	0x590                	BNZ	_00228_DS_
                                           ;	.line	432; usb.c	*inPtr = 0x00;
000572   c0eb     movff	0xeb, 0            	MOVFF	_inPtr, r0x00
000574   f000
000576   c0ec     movff	0xec, 0x1          	MOVFF	(_inPtr + 1), r0x01
000578   f001
00057a   c0ed     movff	0xed, 0x2          	MOVFF	(_inPtr + 2), r0x02
00057c   f002
00057e   6ae5     clrf	0xe5, 0             	CLRF	POSTDEC1
000580   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
000582   ffe9
000584   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
000586   fff3
000588   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
00058a   ec0f     call	0x161e, 0           	CALL	__gptrput1
00058c   f00b
00058e   d00f     bra	0x5ae                	BRA	_00241_DS_
                                           _00228_DS_:
                                           ;	.line	434; usb.c	*inPtr = 0x88;
000590   c0eb     movff	0xeb, 0            	MOVFF	_inPtr, r0x00
000592   f000
000594   c0ec     movff	0xec, 0x1          	MOVFF	(_inPtr + 1), r0x01
000596   f001
000598   c0ed     movff	0xed, 0x2          	MOVFF	(_inPtr + 2), r0x02
00059a   f002
00059c   0e88     movlw	0x88               	MOVLW	0x88
00059e   6ee5     movwf	0xe5, 0            	MOVWF	POSTDEC1
0005a0   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
0005a2   ffe9
0005a4   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
0005a6   fff3
0005a8   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
0005aa   ec0f     call	0x161e, 0           	CALL	__gptrput1
0005ac   f00b
                                           _00241_DS_:
0005ae   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
0005b0   f003
0005b2   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
0005b4   f002
0005b6   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
0005b8   f001
0005ba   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0005bc   f000
0005be   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__GetStatus	code
                                           _GetStatus:
                                           ;	.line	308; usb.c	static void GetStatus(void)
0005c0   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0005c2   ffe5
0005c4   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0005c6   ffe5
0005c8   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
0005ca   ffe5
                                           ;	.line	311; usb.c	byte recipient = SetupPacket.bmRequestType & 0x1F; // D4..0 es Recipient (Dev, Interf o Endp)
0005cc   0e1f     movlw	0x1f               	MOVLW	0x1f
0005ce   0105     movlb	0x5                	BANKSEL	_SetupPacket
0005d0   1580     andwf	0x80, 0, 0x1       	ANDWF	_SetupPacket, W, B
0005d2   6e00     movwf	0, 0               	MOVWF	r0x00
0005d4   0105     movlb	0x5                	BANKSEL	_controlTransferBuffer
                                           ;	.line	313; usb.c	controlTransferBuffer[0] = 0;
0005d6   6bc0     clrf	0xc0, 0x1           	CLRF	_controlTransferBuffer, B
                                           ; removed redundant BANKSEL
                                           ;	.line	314; usb.c	controlTransferBuffer[1] = 0;
0005d8   6bc1     clrf	0xc1, 0x1           	CLRF	(_controlTransferBuffer + 1), B
                                           ;	.line	317; usb.c	if (recipient == 0x00) 
0005da   5000     movf	0, 0, 0             	MOVF	r0x00, W
0005dc   e113     bnz	0x604                	BNZ	_00197_DS_
                                           ;	.line	321; usb.c	requestHandled = 1;
0005de   0e01     movlw	0x1                	MOVLW	0x01
0005e0   0100     movlb	0                  	BANKSEL	_requestHandled
0005e2   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
0005e4   0100     movlb	0                  	BANKSEL	_selfPowered
                                           ;	.line	324; usb.c	if (selfPowered)
0005e6   51f9     movf	0xf9, 0, 0x1        	MOVF	_selfPowered, W, B
0005e8   e004     bz	0x5f2                 	BZ	_00184_DS_
                                           ;	.line	326; usb.c	controlTransferBuffer[0] |= 0x01;
0005ea   0e01     movlw	0x1                	MOVLW	0x01
0005ec   0105     movlb	0x5                	BANKSEL	_controlTransferBuffer
0005ee   11c0     iorwf	0xc0, 0, 0x1       	IORWF	_controlTransferBuffer, W, B
                                           ; #	MOVWF	r0x01
                                           ; #	MOVF	r0x01, W
0005f0   6fc0     movwf	0xc0, 0x1          	MOVWF	_controlTransferBuffer, B
                                           _00184_DS_:
0005f2   0100     movlb	0                  	BANKSEL	_remoteWakeup
                                           ;	.line	327; usb.c	if (remoteWakeup)
0005f4   51fa     movf	0xfa, 0, 0x1        	MOVF	_remoteWakeup, W, B
0005f6   b4d8     btfsc	0xd8, 0x2, 0       	BTFSC	STATUS, 2
0005f8   d047     bra	0x688                	BRA	_00198_DS_
                                           ;	.line	329; usb.c	controlTransferBuffer[0] |= 0x02; 
0005fa   0e02     movlw	0x2                	MOVLW	0x02
0005fc   0105     movlb	0x5                	BANKSEL	_controlTransferBuffer
0005fe   11c0     iorwf	0xc0, 0, 0x1       	IORWF	_controlTransferBuffer, W, B
                                           ; #	MOVWF	r0x01
                                           ; #	MOVF	r0x01, W
000600   6fc0     movwf	0xc0, 0x1          	MOVWF	_controlTransferBuffer, B
000602   d042     bra	0x688                	BRA	_00198_DS_
                                           _00197_DS_:
                                           ;	.line	332; usb.c	else if (recipient == 0x01)  // El descriptor solicitado es la interfaz, 
000604   5000     movf	0, 0, 0             	MOVF	r0x00, W
000606   0a01     xorlw	0x1                	XORLW	0x01
000608   e104     bnz	0x612                	BNZ	_00194_DS_
                                           ;	.line	333; usb.c	requestHandled = 1;
00060a   0e01     movlw	0x1                	MOVLW	0x01
00060c   0100     movlb	0                  	BANKSEL	_requestHandled
00060e   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
000610   d03b     bra	0x688                	BRA	_00198_DS_
                                           _00194_DS_:
                                           ;	.line	335; usb.c	else if (recipient == 0x02) // El descriptor solicitado es un endpoint
000612   5000     movf	0, 0, 0             	MOVF	r0x00, W
000614   0a02     xorlw	0x2                	XORLW	0x02
000616   e001     bz	0x61a                 	BZ	_00215_DS_
000618   d037     bra	0x688                	BRA	_00198_DS_
                                           _00215_DS_:
                                           ;	.line	345; usb.c	byte endpointNum = SetupPacket.wIndex0 & 0x0F;
00061a   0e0f     movlw	0xf                	MOVLW	0x0f
00061c   0105     movlb	0x5                	BANKSEL	(_SetupPacket + 4)
00061e   1584     andwf	0x84, 0, 0x1       	ANDWF	(_SetupPacket + 4), W, B
000620   6e00     movwf	0, 0               	MOVWF	r0x00
                                           ;	.line	347; usb.c	byte endpointDir = SetupPacket.wIndex0 & 0x80;
000622   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
000624   1584     andwf	0x84, 0, 0x1       	ANDWF	(_SetupPacket + 4), W, B
000626   6e01     movwf	0x1, 0             	MOVWF	r0x01
                                           ;	.line	348; usb.c	requestHandled = 1;
000628   0e01     movlw	0x1                	MOVLW	0x01
00062a   0100     movlb	0                  	BANKSEL	_requestHandled
00062c   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ; ;multiply lit val:0x08 by variable r0x00 and store in r0x00
                                           ; ;Unrolled 8 X 8 multiplication
                                           ; ;FIXME: the function does not support result==WREG
                                           ;	.line	355; usb.c	inPtr = (byte *)&ep0Bo + (endpointNum * 8); 
00062e   5000     movf	0, 0, 0             	MOVF	r0x00, W
000630   0d08     mullw	0x8                	MULLW	0x08
000632   cff3     movff	0xff3, 0           	MOVFF	PRODL, r0x00
000634   f000
000636   cff4     movff	0xff4, 0x2         	MOVFF	PRODH, r0x02
000638   f002
00063a   5000     movf	0, 0, 0             	MOVF	r0x00, W
00063c   0100     movlb	0                  	BANKSEL	_inPtr
00063e   6feb     movwf	0xeb, 0x1          	MOVWF	_inPtr, B
000640   0e04     movlw	0x4                	MOVLW	0x04
000642   2402     addwf	0x2, 0, 0          	ADDWF	r0x02, W
                                           ; removed redundant BANKSEL
000644   6fec     movwf	0xec, 0x1          	MOVWF	(_inPtr + 1), B
000646   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
000648   6bed     clrf	0xed, 0x1           	CLRF	(_inPtr + 2), B
00064a   ae02     btfss	0x2, 0x7, 0        	BTFSS	r0x02, 7
00064c   d001     bra	0x650                	BRA	_100507_DS_
                                           ; removed redundant BANKSEL
00064e   69ed     setf	0xed, 0x1           	SETF	(_inPtr + 2), B
                                           _100507_DS_:
000650   0100     movlb	0                  	BANKSEL	(_inPtr + 2)
000652   23ed     addwfc	0xed, 0x1, 0x1    	ADDWFC	(_inPtr + 2), F, B
                                           ;	.line	357; usb.c	if (endpointDir) // Si D7 = 1 es un endpoint de tipo IN
000654   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000656   e005     bz	0x662                 	BZ	_00188_DS_
                                           ;	.line	358; usb.c	inPtr += 4;
000658   0e04     movlw	0x4                	MOVLW	0x04
                                           ; removed redundant BANKSEL
00065a   27eb     addwf	0xeb, 0x1, 0x1     	ADDWF	_inPtr, F, B
00065c   0e00     movlw	0                  	MOVLW	0x00
                                           ; removed redundant BANKSEL
00065e   23ec     addwfc	0xec, 0x1, 0x1    	ADDWFC	(_inPtr + 1), F, B
                                           ; removed redundant BANKSEL
000660   23ed     addwfc	0xed, 0x1, 0x1    	ADDWFC	(_inPtr + 2), F, B
                                           _00188_DS_:
                                           ;	.line	360; usb.c	if(*inPtr & BSTALL) // El valor al que apunta el puntero y el estado del bit D0
000662   c0eb     movff	0xeb, 0            	MOVFF	_inPtr, r0x00
000664   f000
000666   c0ec     movff	0xec, 0x1          	MOVFF	(_inPtr + 1), r0x01
000668   f001
00066a   c0ed     movff	0xed, 0x2          	MOVFF	(_inPtr + 2), r0x02
00066c   f002
00066e   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
000670   ffe9
000672   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
000674   fff3
000676   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000678   ecc9     call	0x1592, 0           	CALL	__gptrget1
00067a   f00a
00067c   6e00     movwf	0, 0               	MOVWF	r0x00
00067e   a400     btfss	0, 0x2, 0          	BTFSS	r0x00, 2
000680   d003     bra	0x688                	BRA	_00198_DS_
                                           ;	.line	361; usb.c	controlTransferBuffer[0] = 0x01;
000682   0e01     movlw	0x1                	MOVLW	0x01
000684   0105     movlb	0x5                	BANKSEL	_controlTransferBuffer
000686   6fc0     movwf	0xc0, 0x1          	MOVWF	_controlTransferBuffer, B
                                           _00198_DS_:
000688   0100     movlb	0                  	BANKSEL	_requestHandled
                                           ;	.line	368; usb.c	if (requestHandled)
00068a   51f8     movf	0xf8, 0, 0x1        	MOVF	_requestHandled, W, B
00068c   e00b     bz	0x6a4                 	BZ	_00201_DS_
                                           ;	.line	370; usb.c	outPtr = (byte *)&controlTransferBuffer;
00068e   0e05     movlw	0x5                	MOVLW	HIGH(_controlTransferBuffer)
000690   0100     movlb	0                  	BANKSEL	(_outPtr + 1)
000692   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000694   0ec0     movlw	0xc0               	MOVLW	LOW(_controlTransferBuffer)
                                           ; removed redundant BANKSEL
000696   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000698   0e80     movlw	0x80               	MOVLW	0x80
                                           ; removed redundant BANKSEL
00069a   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	371; usb.c	wCount = 2;
00069c   0e02     movlw	0x2                	MOVLW	0x02
00069e   0100     movlb	0                  	BANKSEL	_wCount
0006a0   6fee     movwf	0xee, 0x1          	MOVWF	_wCount, B
                                           ; removed redundant BANKSEL
0006a2   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
                                           _00201_DS_:
0006a4   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
0006a6   f002
0006a8   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
0006aa   f001
0006ac   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
0006ae   f000
0006b0   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__GetDescriptor	code
                                           _GetDescriptor:
                                           ;	.line	258; usb.c	static void GetDescriptor(void)
0007a0   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0007a2   ffe5
0007a4   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0007a6   ffe5
0007a8   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
0007aa   ffe5
0007ac   0105     movlb	0x5                	BANKSEL	_SetupPacket
                                           ;	.line	260; usb.c	if(SetupPacket.bmRequestType == 0x80)  // Direccin del dato de dispositivo a host
0007ae   5180     movf	0x80, 0, 0x1        	MOVF	_SetupPacket, W, B
0007b0   0a80     xorlw	0x80               	XORLW	0x80
0007b2   e001     bz	0x7b6                 	BZ	_00170_DS_
0007b4   d065     bra	0x880                	BRA	_00161_DS_
                                           _00170_DS_:
                                           ;	.line	262; usb.c	byte descriptorType  = SetupPacket.wValue1; // El MSB contiene el tipo de descriptor
0007b6   c583     movff	0x583, 0           	MOVFF	(_SetupPacket + 3), r0x00
0007b8   f000
                                           ;	.line	263; usb.c	byte descriptorIndex = SetupPacket.wValue0; // El LSB contiene el ndice de descriptor
0007ba   c582     movff	0x582, 0x1         	MOVFF	(_SetupPacket + 2), r0x01
0007bc   f001
                                           ;	.line	266; usb.c	if (descriptorType == DEVICE_DESCRIPTOR) // Indentifica si la solicitud es de dispositivo
0007be   5000     movf	0, 0, 0             	MOVF	r0x00, W
0007c0   0a01     xorlw	0x1                	XORLW	0x01
0007c2   e10f     bnz	0x7e2                	BNZ	_00157_DS_
                                           ;	.line	268; usb.c	requestHandled = 1;		// La solicitud fue tomada
0007c4   0e01     movlw	0x1                	MOVLW	0x01
0007c6   0100     movlb	0                  	BANKSEL	_requestHandled
0007c8   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	269; usb.c	outPtr = (byte *)&deviceDescriptor; // Apunta a la direccin del descriptor
0007ca   0e3c     movlw	0x3c               	MOVLW	LOW(_deviceDescriptor)
0007cc   0100     movlb	0                  	BANKSEL	_outPtr
0007ce   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
0007d0   0e12     movlw	0x12               	MOVLW	HIGH(_deviceDescriptor)
                                           ; removed redundant BANKSEL
0007d2   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
0007d4   0e00     movlw	0                  	MOVLW	UPPER(_deviceDescriptor)
                                           ; removed redundant BANKSEL
0007d6   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	270; usb.c	wCount = DEVICE_DESCRIPTOR_SIZE; // El tamao de este descriptor es de 0x12 bytes
0007d8   0e12     movlw	0x12               	MOVLW	0x12
0007da   0100     movlb	0                  	BANKSEL	_wCount
0007dc   6fee     movwf	0xee, 0x1          	MOVWF	_wCount, B
                                           ; removed redundant BANKSEL
0007de   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
0007e0   d04f     bra	0x880                	BRA	_00161_DS_
                                           _00157_DS_:
                                           ;	.line	274; usb.c	else if (descriptorType == CONFIGURATION_DESCRIPTOR) // Si la solicitud es de configuracin
0007e2   5000     movf	0, 0, 0             	MOVF	r0x00, W
0007e4   0a02     xorlw	0x2                	XORLW	0x02
0007e6   e118     bnz	0x818                	BNZ	_00154_DS_
                                           ;	.line	276; usb.c	requestHandled = 1;
0007e8   0e01     movlw	0x1                	MOVLW	0x01
0007ea   0100     movlb	0                  	BANKSEL	_requestHandled
0007ec   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	277; usb.c	outPtr = (byte *)&configDescriptor;
0007ee   0e4e     movlw	0x4e               	MOVLW	LOW(_configDescriptor)
0007f0   0100     movlb	0                  	BANKSEL	_outPtr
0007f2   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
0007f4   0e12     movlw	0x12               	MOVLW	HIGH(_configDescriptor)
                                           ; removed redundant BANKSEL
0007f6   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
0007f8   0e00     movlw	0                  	MOVLW	UPPER(_configDescriptor)
                                           ; removed redundant BANKSEL
0007fa   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           ;	.line	278; usb.c	wCount = configDescriptor.configHeader[2]; // Note: SDCC makes bad code with this
0007fc   0e50     movlw	0x50               	MOVLW	LOW(_configDescriptor + 2)
0007fe   6ef6     movwf	0xf6, 0            	MOVWF	TBLPTRL
000800   0e12     movlw	0x12               	MOVLW	HIGH(_configDescriptor + 2)
000802   6ef7     movwf	0xf7, 0            	MOVWF	TBLPTRH
000804   0e00     movlw	0                  	MOVLW	UPPER(_configDescriptor + 2)
000806   6ef8     movwf	0xf8, 0            	MOVWF	TBLPTRU
000808   0009     tblrd	*+                 	TBLRD*+	
00080a   cff5     movff	0xff5, 0x2         	MOVFF	TABLAT, r0x02
00080c   f002
00080e   c002     movff	0x2, 0xee          	MOVFF	r0x02, _wCount
000810   f0ee
000812   0100     movlb	0                  	BANKSEL	(_wCount + 1)
000814   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
000816   d034     bra	0x880                	BRA	_00161_DS_
                                           _00154_DS_:
                                           ;	.line	283; usb.c	else if (descriptorType == STRING_DESCRIPTOR) // Indentifica si la solicitud es string
000818   5000     movf	0, 0, 0             	MOVF	r0x00, W
00081a   0a03     xorlw	0x3                	XORLW	0x03
00081c   e131     bnz	0x880                	BNZ	_00161_DS_
                                           ;	.line	285; usb.c	requestHandled = 1;
00081e   0e01     movlw	0x1                	MOVLW	0x01
000820   0100     movlb	0                  	BANKSEL	_requestHandled
000822   6ff8     movwf	0xf8, 0x1          	MOVWF	_requestHandled, B
                                           ;	.line	286; usb.c	if (descriptorIndex == 0)	// El primer string contiene el Codigo de lenguaje
000824   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
000826   e108     bnz	0x838                	BNZ	_00149_DS_
                                           ;	.line	287; usb.c	outPtr = &stringDescriptor0; // Apunta a la direccin del primer descriptor
000828   0e6e     movlw	0x6e               	MOVLW	LOW(_stringDescriptor0)
00082a   0100     movlb	0                  	BANKSEL	_outPtr
00082c   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
00082e   0e12     movlw	0x12               	MOVLW	HIGH(_stringDescriptor0)
                                           ; removed redundant BANKSEL
000830   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000832   0e00     movlw	0                  	MOVLW	UPPER(_stringDescriptor0)
                                           ; removed redundant BANKSEL
000834   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
000836   d012     bra	0x85c                	BRA	_00150_DS_
                                           _00149_DS_:
                                           ;	.line	288; usb.c	else if (descriptorIndex == 1)  // Gralmente el segundo trae el nombre del autor
000838   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
00083a   0a01     xorlw	0x1                	XORLW	0x01
00083c   e108     bnz	0x84e                	BNZ	_00146_DS_
                                           ;	.line	289; usb.c	outPtr = &stringDescriptor1;
00083e   0e72     movlw	0x72               	MOVLW	LOW(_stringDescriptor1)
000840   0100     movlb	0                  	BANKSEL	_outPtr
000842   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000844   0e12     movlw	0x12               	MOVLW	HIGH(_stringDescriptor1)
                                           ; removed redundant BANKSEL
000846   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000848   0e00     movlw	0                  	MOVLW	UPPER(_stringDescriptor1)
                                           ; removed redundant BANKSEL
00084a   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
00084c   d007     bra	0x85c                	BRA	_00150_DS_
                                           _00146_DS_:
                                           ;	.line	291; usb.c	outPtr = &stringDescriptor2; // Y el ultimo el nombre del dispositivo
00084e   0e8c     movlw	0x8c               	MOVLW	LOW(_stringDescriptor2)
000850   0100     movlb	0                  	BANKSEL	_outPtr
000852   6fe8     movwf	0xe8, 0x1          	MOVWF	_outPtr, B
000854   0e12     movlw	0x12               	MOVLW	HIGH(_stringDescriptor2)
                                           ; removed redundant BANKSEL
000856   6fe9     movwf	0xe9, 0x1          	MOVWF	(_outPtr + 1), B
000858   0e00     movlw	0                  	MOVLW	UPPER(_stringDescriptor2)
                                           ; removed redundant BANKSEL
00085a   6fea     movwf	0xea, 0x1          	MOVWF	(_outPtr + 2), B
                                           _00150_DS_:
                                           ;	.line	292; usb.c	wCount = *outPtr;	// Devuelve la indireccin del puntero ya que el primer
00085c   c0e8     movff	0xe8, 0            	MOVFF	_outPtr, r0x00
00085e   f000
000860   c0e9     movff	0xe9, 0x1          	MOVFF	(_outPtr + 1), r0x01
000862   f001
000864   c0ea     movff	0xea, 0x2          	MOVFF	(_outPtr + 2), r0x02
000866   f002
000868   c000     movff	0, 0xfe9           	MOVFF	r0x00, FSR0L
00086a   ffe9
00086c   c001     movff	0x1, 0xff3         	MOVFF	r0x01, PRODL
00086e   fff3
000870   5002     movf	0x2, 0, 0           	MOVF	r0x02, W
000872   ecc9     call	0x1592, 0           	CALL	__gptrget1
000874   f00a
000876   6e00     movwf	0, 0               	MOVWF	r0x00
000878   c000     movff	0, 0xee            	MOVFF	r0x00, _wCount
00087a   f0ee
00087c   0100     movlb	0                  	BANKSEL	(_wCount + 1)
00087e   6bef     clrf	0xef, 0x1           	CLRF	(_wCount + 1), B
                                           _00161_DS_:
000880   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000882   f002
000884   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000886   f001
000888   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
00088a   f000
00088c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__BulkOut	code
                                           _BulkOut:
                                           ;	.line	222; usb.c	byte BulkOut(byte *buffer, byte len)
00088e   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
000890   ffe5
000892   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
000894   ffd9
000896   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000898   ffe5
00089a   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
00089c   ffe5
00089e   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
0008a0   ffe5
0008a2   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
0008a4   ffe5
0008a6   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
0008a8   ffe5
0008aa   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
0008ac   ffe5
0008ae   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
0008b0   ffe5
0008b2   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
0008b4   ffe5
0008b6   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
0008b8   ffe5
0008ba   0e02     movlw	0x2                	MOVLW	0x02
0008bc   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
0008be   f000
0008c0   0e03     movlw	0x3                	MOVLW	0x03
0008c2   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
0008c4   f001
0008c6   0e04     movlw	0x4                	MOVLW	0x04
0008c8   cfdb     movff	0xfdb, 0x2         	MOVFF	PLUSW2, r0x02
0008ca   f002
0008cc   0e05     movlw	0x5                	MOVLW	0x05
0008ce   cfdb     movff	0xfdb, 0x3         	MOVFF	PLUSW2, r0x03
0008d0   f003
0008d2   0100     movlb	0                  	BANKSEL	_RxLen
                                           ;	.line	224; usb.c	RxLen = 0;
0008d4   6bf7     clrf	0xf7, 0x1           	CLRF	_RxLen, B
0008d6   0104     movlb	0x4                	BANKSEL	_ep1Bo
                                           ;	.line	227; usb.c	if(!(ep1Bo.Stat & UOWN))
0008d8   bf08     btfsc	0x8, 0x7, 0x1      	BTFSC	_ep1Bo, 7, B
0008da   d039     bra	0x94e                	BRA	_00136_DS_
                                           ;	.line	230; usb.c	if(len > ep1Bo.Cnt)
0008dc   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
                                           ; #	SUBWF	(_ep1Bo + 1), W, B
                                           ; #	BTFSC	STATUS, 0
                                           ; #	GOTO	_00131_DS_
                                           ; #	MOVFF	(_ep1Bo + 1), r0x03
                                           ; #	CLRF	_RxLen, B
0008de   0104     movlb	0x4                	BANKSEL	(_ep1Bo + 1)
                                           ;	.line	231; usb.c	len = ep1Bo.Cnt;
0008e0   5d09     subwf	0x9, 0, 0x1        	SUBWF	(_ep1Bo + 1), W, B
                                           ;	.line	234; usb.c	for(RxLen = 0; RxLen < len; RxLen++)
0008e2   a0d8     btfss	0xd8, 0, 0         	BTFSS	STATUS, 0
0008e4   c409     movff	0x409, 0x3         	MOVFF	(_ep1Bo + 1), r0x03
0008e6   f003
0008e8   0100     movlb	0                  	BANKSEL	_RxLen
0008ea   6bf7     clrf	0xf7, 0x1           	CLRF	_RxLen, B
                                           _00137_DS_:
0008ec   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
0008ee   0100     movlb	0                  	BANKSEL	_RxLen
0008f0   5df7     subwf	0xf7, 0, 0x1       	SUBWF	_RxLen, W, B
0008f2   e221     bc	0x936                 	BC	_00140_DS_
                                           ; removed redundant BANKSEL
                                           ;	.line	235; usb.c	buffer[RxLen] = RxBuffer[RxLen];
0008f4   51f7     movf	0xf7, 0, 0x1        	MOVF	_RxLen, W, B
0008f6   2400     addwf	0, 0, 0            	ADDWF	r0x00, W
0008f8   6e04     movwf	0x4, 0             	MOVWF	r0x04
0008fa   6ae8     clrf	0xe8, 0             	CLRF	WREG
0008fc   2001     addwfc	0x1, 0, 0         	ADDWFC	r0x01, W
0008fe   6e05     movwf	0x5, 0             	MOVWF	r0x05
000900   6ae8     clrf	0xe8, 0             	CLRF	WREG
000902   2002     addwfc	0x2, 0, 0         	ADDWFC	r0x02, W
000904   6e06     movwf	0x6, 0             	MOVWF	r0x06
000906   0e00     movlw	0                  	MOVLW	LOW(_RxBuffer)
                                           ; removed redundant BANKSEL
000908   25f7     addwf	0xf7, 0, 0x1       	ADDWF	_RxLen, W, B
00090a   6e07     movwf	0x7, 0             	MOVWF	r0x07
00090c   6a08     clrf	0x8, 0              	CLRF	r0x08
00090e   0e05     movlw	0x5                	MOVLW	HIGH(_RxBuffer)
000910   2208     addwfc	0x8, 0x1, 0       	ADDWFC	r0x08, F
000912   c007     movff	0x7, 0xfe9         	MOVFF	r0x07, FSR0L
000914   ffe9
000916   c008     movff	0x8, 0xfea         	MOVFF	r0x08, FSR0H
000918   ffea
00091a   cfef     movff	0xfef, 0x7         	MOVFF	INDF0, r0x07
00091c   f007
00091e   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
000920   ffe5
000922   c004     movff	0x4, 0xfe9         	MOVFF	r0x04, FSR0L
000924   ffe9
000926   c005     movff	0x5, 0xff3         	MOVFF	r0x05, PRODL
000928   fff3
00092a   5006     movf	0x6, 0, 0           	MOVF	r0x06, W
00092c   ec0f     call	0x161e, 0           	CALL	__gptrput1
00092e   f00b
000930   0100     movlb	0                  	BANKSEL	_RxLen
                                           ;	.line	234; usb.c	for(RxLen = 0; RxLen < len; RxLen++)
000932   2bf7     incf	0xf7, 0x1, 0x1      	INCF	_RxLen, F, B
000934   d7db     bra	0x8ec                	BRA	_00137_DS_
                                           _00140_DS_:
                                           ;	.line	239; usb.c	ep1Bo.Cnt = sizeof(RxBuff);
000936   0e40     movlw	0x40               	MOVLW	0x40
000938   0104     movlb	0x4                	BANKSEL	(_ep1Bo + 1)
00093a   6f09     movwf	0x9, 0x1           	MOVWF	(_ep1Bo + 1), B
00093c   0104     movlb	0x4                	BANKSEL	_ep1Bo
                                           ;	.line	240; usb.c	if(ep1Bo.Stat & DTS)
00093e   ad08     btfss	0x8, 0x6, 0x1      	BTFSS	_ep1Bo, 6, B
000940   d003     bra	0x948                	BRA	_00133_DS_
                                           ;	.line	241; usb.c	ep1Bo.Stat = UOWN | DTSEN;
000942   0e88     movlw	0x88               	MOVLW	0x88
                                           ; removed redundant BANKSEL
000944   6f08     movwf	0x8, 0x1           	MOVWF	_ep1Bo, B
000946   d003     bra	0x94e                	BRA	_00136_DS_
                                           _00133_DS_:
                                           ;	.line	243; usb.c	ep1Bo.Stat = UOWN | DTS | DTSEN;
000948   0ec8     movlw	0xc8               	MOVLW	0xc8
00094a   0104     movlb	0x4                	BANKSEL	_ep1Bo
00094c   6f08     movwf	0x8, 0x1           	MOVWF	_ep1Bo, B
                                           _00136_DS_:
00094e   0100     movlb	0                  	BANKSEL	_RxLen
                                           ;	.line	247; usb.c	return RxLen;
000950   51f7     movf	0xf7, 0, 0x1        	MOVF	_RxLen, W, B
000952   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
000954   f008
000956   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
000958   f007
00095a   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
00095c   f006
00095e   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
000960   f005
000962   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000964   f004
000966   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000968   f003
00096a   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
00096c   f002
00096e   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000970   f001
000972   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000974   f000
000976   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
000978   ffd9
00097a   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__BulkIn	code
                                           _BulkIn:
                                           ;	.line	193; usb.c	byte BulkIn(byte *buffer, byte len)
000c32   cfd9     movff	0xfd9, 0xfe5       	MOVFF	FSR2L, POSTDEC1
000c34   ffe5
000c36   cfe1     movff	0xfe1, 0xfd9       	MOVFF	FSR1L, FSR2L
000c38   ffd9
000c3a   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
000c3c   ffe5
000c3e   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
000c40   ffe5
000c42   c002     movff	0x2, 0xfe5         	MOVFF	r0x02, POSTDEC1
000c44   ffe5
000c46   c003     movff	0x3, 0xfe5         	MOVFF	r0x03, POSTDEC1
000c48   ffe5
000c4a   c004     movff	0x4, 0xfe5         	MOVFF	r0x04, POSTDEC1
000c4c   ffe5
000c4e   c005     movff	0x5, 0xfe5         	MOVFF	r0x05, POSTDEC1
000c50   ffe5
000c52   c006     movff	0x6, 0xfe5         	MOVFF	r0x06, POSTDEC1
000c54   ffe5
000c56   c007     movff	0x7, 0xfe5         	MOVFF	r0x07, POSTDEC1
000c58   ffe5
000c5a   c008     movff	0x8, 0xfe5         	MOVFF	r0x08, POSTDEC1
000c5c   ffe5
000c5e   0e02     movlw	0x2                	MOVLW	0x02
000c60   cfdb     movff	0xfdb, 0           	MOVFF	PLUSW2, r0x00
000c62   f000
000c64   0e03     movlw	0x3                	MOVLW	0x03
000c66   cfdb     movff	0xfdb, 0x1         	MOVFF	PLUSW2, r0x01
000c68   f001
000c6a   0e04     movlw	0x4                	MOVLW	0x04
000c6c   cfdb     movff	0xfdb, 0x2         	MOVFF	PLUSW2, r0x02
000c6e   f002
000c70   0e05     movlw	0x5                	MOVLW	0x05
000c72   cfdb     movff	0xfdb, 0x3         	MOVFF	PLUSW2, r0x03
000c74   f003
000c76   0104     movlb	0x4                	BANKSEL	_ep1Bi
                                           ;	.line	199; usb.c	if (ep1Bi.Stat & UOWN)
000c78   af0c     btfss	0xc, 0x7, 0x1      	BTFSS	_ep1Bi, 7, B
000c7a   d002     bra	0xc80                	BRA	_00110_DS_
                                           ;	.line	200; usb.c	return 0;
000c7c   6ae8     clrf	0xe8, 0             	CLRF	WREG
000c7e   d033     bra	0xce6                	BRA	_00120_DS_
                                           _00110_DS_:
                                           ;	.line	203; usb.c	if(len > ISZ)
000c80   0e41     movlw	0x41               	MOVLW	0x41
000c82   5c03     subwf	0x3, 0, 0          	SUBWF	r0x03, W
000c84   e302     bnc	0xc8a                	BNC	_00125_DS_
                                           ;	.line	204; usb.c	len = ISZ;
000c86   0e40     movlw	0x40               	MOVLW	0x40
000c88   6e03     movwf	0x3, 0             	MOVWF	r0x03
                                           _00125_DS_:
                                           ;	.line	207; usb.c	for (i = 0; i < len; i++)
000c8a   6a04     clrf	0x4, 0              	CLRF	r0x04
                                           _00116_DS_:
000c8c   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
000c8e   5c04     subwf	0x4, 0, 0          	SUBWF	r0x04, W
000c90   e21d     bc	0xccc                 	BC	_00119_DS_
                                           ;	.line	208; usb.c	TxBuffer[i] = buffer[i];
000c92   0e40     movlw	0x40               	MOVLW	LOW(_TxBuffer)
000c94   2404     addwf	0x4, 0, 0          	ADDWF	r0x04, W
000c96   6e05     movwf	0x5, 0             	MOVWF	r0x05
000c98   6a06     clrf	0x6, 0              	CLRF	r0x06
000c9a   0e05     movlw	0x5                	MOVLW	HIGH(_TxBuffer)
000c9c   2206     addwfc	0x6, 0x1, 0       	ADDWFC	r0x06, F
000c9e   5004     movf	0x4, 0, 0           	MOVF	r0x04, W
000ca0   2400     addwf	0, 0, 0            	ADDWF	r0x00, W
000ca2   6e07     movwf	0x7, 0             	MOVWF	r0x07
000ca4   6ae8     clrf	0xe8, 0             	CLRF	WREG
000ca6   2001     addwfc	0x1, 0, 0         	ADDWFC	r0x01, W
000ca8   6e08     movwf	0x8, 0             	MOVWF	r0x08
000caa   6ae8     clrf	0xe8, 0             	CLRF	WREG
000cac   2002     addwfc	0x2, 0, 0         	ADDWFC	r0x02, W
000cae   c007     movff	0x7, 0xfe9         	MOVFF	r0x07, FSR0L
000cb0   ffe9
000cb2   c008     movff	0x8, 0xff3         	MOVFF	r0x08, PRODL
000cb4   fff3
000cb6   ecc9     call	0x1592, 0           	CALL	__gptrget1
000cb8   f00a
000cba   6e07     movwf	0x7, 0             	MOVWF	r0x07
000cbc   c005     movff	0x5, 0xfe9         	MOVFF	r0x05, FSR0L
000cbe   ffe9
000cc0   c006     movff	0x6, 0xfea         	MOVFF	r0x06, FSR0H
000cc2   ffea
000cc4   c007     movff	0x7, 0xfef         	MOVFF	r0x07, INDF0
000cc6   ffef
                                           ;	.line	207; usb.c	for (i = 0; i < len; i++)
000cc8   2a04     incf	0x4, 0x1, 0         	INCF	r0x04, F
000cca   d7e0     bra	0xc8c                	BRA	_00116_DS_
                                           _00119_DS_:
                                           ;	.line	211; usb.c	ep1Bi.Cnt = len;
000ccc   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
000cce   0104     movlb	0x4                	BANKSEL	(_ep1Bi + 1)
000cd0   6f0d     movwf	0xd, 0x1           	MOVWF	(_ep1Bi + 1), B
000cd2   0104     movlb	0x4                	BANKSEL	_ep1Bi
                                           ;	.line	212; usb.c	if(ep1Bi.Stat & DTS)
000cd4   ad0c     btfss	0xc, 0x6, 0x1      	BTFSS	_ep1Bi, 6, B
000cd6   d003     bra	0xcde                	BRA	_00114_DS_
                                           ;	.line	213; usb.c	ep1Bi.Stat = UOWN | DTSEN;
000cd8   0e88     movlw	0x88               	MOVLW	0x88
                                           ; removed redundant BANKSEL
000cda   6f0c     movwf	0xc, 0x1           	MOVWF	_ep1Bi, B
000cdc   d003     bra	0xce4                	BRA	_00115_DS_
                                           _00114_DS_:
                                           ;	.line	215; usb.c	ep1Bi.Stat = UOWN | DTS | DTSEN;
000cde   0ec8     movlw	0xc8               	MOVLW	0xc8
000ce0   0104     movlb	0x4                	BANKSEL	_ep1Bi
000ce2   6f0c     movwf	0xc, 0x1           	MOVWF	_ep1Bi, B
                                           _00115_DS_:
                                           ;	.line	218; usb.c	return len;
000ce4   5003     movf	0x3, 0, 0           	MOVF	r0x03, W
                                           _00120_DS_:
000ce6   cfe4     movff	0xfe4, 0x8         	MOVFF	PREINC1, r0x08
000ce8   f008
000cea   cfe4     movff	0xfe4, 0x7         	MOVFF	PREINC1, r0x07
000cec   f007
000cee   cfe4     movff	0xfe4, 0x6         	MOVFF	PREINC1, r0x06
000cf0   f006
000cf2   cfe4     movff	0xfe4, 0x5         	MOVFF	PREINC1, r0x05
000cf4   f005
000cf6   cfe4     movff	0xfe4, 0x4         	MOVFF	PREINC1, r0x04
000cf8   f004
000cfa   cfe4     movff	0xfe4, 0x3         	MOVFF	PREINC1, r0x03
000cfc   f003
000cfe   cfe4     movff	0xfe4, 0x2         	MOVFF	PREINC1, r0x02
000d00   f002
000d02   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
000d04   f001
000d06   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
000d08   f000
000d0a   cfe4     movff	0xfe4, 0xfd9       	MOVFF	PREINC1, FSR2L
000d0c   ffd9
000d0e   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block
                                           S_usb__InitEndpoint	code
                                           _InitEndpoint:
                                           ;	.line	171; usb.c	void InitEndpoint(void)
0013e0   c000     movff	0, 0xfe5           	MOVFF	r0x00, POSTDEC1
0013e2   ffe5
0013e4   c001     movff	0x1, 0xfe5         	MOVFF	r0x01, POSTDEC1
0013e6   ffe5
0013e8   0100     movlb	0                  	BANKSEL	_RxLen
                                           ;	.line	173; usb.c	RxLen = 0;
0013ea   6bf7     clrf	0xf7, 0x1           	CLRF	_RxLen, B
                                           ;	.line	176; usb.c	UEP1 = 0x1E;  // Ver hoja de datos PIC pag 169 (USB Endpoint 1 Control)
0013ec   0e1e     movlw	0x1e               	MOVLW	0x1e
0013ee   6e71     movwf	0x71, 0            	MOVWF	_UEP1
                                           ;	.line	178; usb.c	ep1Bo.Cnt = sizeof(RxBuffer);
0013f0   0e40     movlw	0x40               	MOVLW	0x40
0013f2   0104     movlb	0x4                	BANKSEL	(_ep1Bo + 1)
0013f4   6f09     movwf	0x9, 0x1           	MOVWF	(_ep1Bo + 1), B
                                           ;	.line	180; usb.c	ep1Bo.ADDR = PTR16(&RxBuffer);
0013f6   0e00     movlw	0                  	MOVLW	LOW(_RxBuffer)
0013f8   6e00     movwf	0, 0               	MOVWF	r0x00
0013fa   0e05     movlw	0x5                	MOVLW	HIGH(_RxBuffer)
0013fc   6e01     movwf	0x1, 0             	MOVWF	r0x01
0013fe   5000     movf	0, 0, 0             	MOVF	r0x00, W
                                           ; removed redundant BANKSEL
001400   6f0a     movwf	0xa, 0x1           	MOVWF	(_ep1Bo + 2), B
001402   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
001404   6f0b     movwf	0xb, 0x1           	MOVWF	(_ep1Bo + 3), B
                                           ;	.line	182; usb.c	ep1Bo.Stat = UOWN | DTSEN;
001406   0e88     movlw	0x88               	MOVLW	0x88
001408   0104     movlb	0x4                	BANKSEL	_ep1Bo
00140a   6f08     movwf	0x8, 0x1           	MOVWF	_ep1Bo, B
                                           ;	.line	184; usb.c	ep1Bi.ADDR = PTR16(&TxBuffer);
00140c   0e40     movlw	0x40               	MOVLW	LOW(_TxBuffer)
00140e   6e00     movwf	0, 0               	MOVWF	r0x00
001410   0e05     movlw	0x5                	MOVLW	HIGH(_TxBuffer)
001412   6e01     movwf	0x1, 0             	MOVWF	r0x01
001414   5000     movf	0, 0, 0             	MOVF	r0x00, W
001416   0104     movlb	0x4                	BANKSEL	(_ep1Bi + 2)
001418   6f0e     movwf	0xe, 0x1           	MOVWF	(_ep1Bi + 2), B
00141a   5001     movf	0x1, 0, 0           	MOVF	r0x01, W
                                           ; removed redundant BANKSEL
00141c   6f0f     movwf	0xf, 0x1           	MOVWF	(_ep1Bi + 3), B
                                           ;	.line	186; usb.c	ep1Bi.Stat = DTS;
00141e   0e40     movlw	0x40               	MOVLW	0x40
001420   0104     movlb	0x4                	BANKSEL	_ep1Bi
001422   6f0c     movwf	0xc, 0x1           	MOVWF	_ep1Bi, B
001424   cfe4     movff	0xfe4, 0x1         	MOVFF	PREINC1, r0x01
001426   f001
001428   cfe4     movff	0xfe4, 0           	MOVFF	PREINC1, r0x00
00142a   f000
00142c   0012     return	0                 	RETURN	
                                           
                                           ; ; Starting pCode block for Ival
                                           	code
                                           _deviceDescriptor:
00123c   0112     movlb	0x12               	DB	0x12, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0xd8, 0x04, 0x31, 0x75
00123e   0200     mulwf	0, 0               
001240   0000     nop                      
001242   4000     rrncf	0, 0, 0            
001244   04d8     decf	0xd8, 0, 0          
001246   7531     btg	0x31, 0x2, 0x1       
001248   0001     dw	0x1  ;unknown opcode  	DB	0x01, 0x00, 0x01, 0x02, 0x00, 0x01
00124a   0201     mulwf	0x1, 0             
00124c   0100     movlb	0                  
                                           ; ; Starting pCode block for Ival
                                           _configDescriptor:
00124e   0209     mulwf	0x9, 0             	DB	0x09, 0x02, 0x20, 0x00, 0x01, 0x01, 0x00, 0xa0, 0x32, 0x09, 0x04, 0x00
001250   0020     dw	0x20  ;unknown opcode 
001252   0101     movlb	0x1                
001254   a000     btfss	0, 0, 0            
001256   0932     iorlw	0x32               
001258   0004     clrwdt                   
00125a   0200     mulwf	0, 0               	DB	0x00, 0x02, 0x07, 0x01, 0x00, 0x00, 0x07, 0x05, 0x81, 0x02, 0x40, 0x00
00125c   0107     movlb	0x7                
00125e   0000     nop                      
001260   0507     decf	0x7, 0, 0x1         
001262   0281     mulwf	0x81, 0            
001264   0040     dw	0x40  ;unknown opcode 
001266   0701     decf	0x1, 0x1, 0x1       	DB	0x01, 0x07, 0x05, 0x01, 0x02, 0x40, 0x00, 0x01
001268   0105     movlb	0x5                
00126a   4002     rrncf	0x2, 0, 0          
00126c   0100     movlb	0                  
                                           ; ; Starting pCode block for Ival
                                           _stringDescriptor0:
00126e   0304     mulwf	0x4, 0x1           	DB	0x04, 0x03, 0x09, 0x04
001270   0409     decf	0x9, 0, 0           
                                           ; ; Starting pCode block for Ival
                                           _stringDescriptor1:
001272   031a     mulwf	0x1a, 0x1          	DB	0x1a, 0x03, 0x45, 0x00, 0x6d, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x73, 0x00
001274   0045     dw	0x45  ;unknown opcode 
001276   006d     dw	0x6d  ;unknown opcode 
001278   0062     dw	0x62  ;unknown opcode 
00127a   006f     dw	0x6f  ;unknown opcode 
00127c   0073     dw	0x73  ;unknown opcode 
00127e   0073     dw	0x73  ;unknown opcode 	DB	0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00
001280   0065     dw	0x65  ;unknown opcode 
001282   0072     dw	0x72  ;unknown opcode 
001284   0020     dw	0x20  ;unknown opcode 
001286   0020     dw	0x20  ;unknown opcode 
001288   0020     dw	0x20  ;unknown opcode 
00128a   0020     dw	0x20  ;unknown opcode 	DB	0x20, 0x00
                                           ; ; Starting pCode block for Ival
                                           _stringDescriptor2:
00128c   0320     mulwf	0x20, 0x1          	DB	0x20, 0x03, 0x55, 0x00, 0x53, 0x00, 0x42, 0x00, 0x20, 0x00, 0x42, 0x00
00128e   0055     dw	0x55  ;unknown opcode 
001290   0053     dw	0x53  ;unknown opcode 
001292   0042     dw	0x42  ;unknown opcode 
001294   0020     dw	0x20  ;unknown opcode 
001296   0042     dw	0x42  ;unknown opcode 
001298   0072     dw	0x72  ;unknown opcode 	DB	0x72, 0x00, 0x61, 0x00, 0x69, 0x00, 0x6c, 0x00, 0x6c, 0x00, 0x65, 0x00
00129a   0061     dw	0x61  ;unknown opcode 
00129c   0069     dw	0x69  ;unknown opcode 
00129e   006c     dw	0x6c  ;unknown opcode 
0012a0   006c     dw	0x6c  ;unknown opcode 
0012a2   0065     dw	0x65  ;unknown opcode 
0012a4   0020     dw	0x20  ;unknown opcode 	DB	0x20, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x31, 0x00
0012a6   0030     dw	0x30  ;unknown opcode 
0012a8   002e     dw	0x2e  ;unknown opcode 
0012aa   0031     dw	0x31  ;unknown opcode 
                                           
                                           
                                           ; Statistics:
                                           ; code size:	 2782 (0x0ade) bytes ( 2.12%)
                                           ;           	 1391 (0x056f) words
                                           ; udata size:	  288 (0x0120) bytes (16.07%)
                                           ; access size:	   10 (0x000a) bytes
                                           
                                           
                                           	end
